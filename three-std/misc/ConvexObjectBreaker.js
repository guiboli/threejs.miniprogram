!function(){var e,t;e=this,t=function(e,t,o){"use strict";const s=new t.Vector3;class n{constructor(e=1.4,o=1e-4){this.minSizeForBreak=e,this.smallDelta=o,this.tempLine1=new t.Line3,this.tempPlane1=new t.Plane,this.tempPlane2=new t.Plane,this.tempPlane_Cut=new t.Plane,this.tempCM1=new t.Vector3,this.tempCM2=new t.Vector3,this.tempVector3=new t.Vector3,this.tempVector3_2=new t.Vector3,this.tempVector3_3=new t.Vector3,this.tempVector3_P0=new t.Vector3,this.tempVector3_P1=new t.Vector3,this.tempVector3_P2=new t.Vector3,this.tempVector3_N0=new t.Vector3,this.tempVector3_N1=new t.Vector3,this.tempVector3_AB=new t.Vector3,this.tempVector3_CB=new t.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(let e=0;e<900;e++)this.segments[e]=!1}prepareBreakableObject(e,t,o,s,n){e.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");const r=e.userData;r.mass=t,r.velocity=o.clone(),r.angularVelocity=s.clone(),r.breakable=n}subdivideByImpact(e,t,o,s,n){const r=[],i=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(t,o),i.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=n+s,l=this;return function n(m,p,h,u){if(Math.random()<.05*u||u>c)return void r.push(m);let d=Math.PI;0===u?(a.normal.copy(i.normal),a.constant=i.constant):u<=s?(d=(h-p)*(.2+.6*Math.random())+p,l.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(o,d).add(t),a.setFromCoplanarPoints(t,l.tempVector3,l.tempVector3_2)):(d=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,l.tempVector3_2.copy(t).sub(m.position).applyAxisAngle(o,d).add(m.position),l.tempVector3_3.copy(o).add(m.position),a.setFromCoplanarPoints(m.position,l.tempVector3_3,l.tempVector3_2)),l.cutByPlane(m,a,l.tempResultObjects);const y=l.tempResultObjects.object1,V=l.tempResultObjects.object2;y&&n(y,p,d,u+1),V&&n(V,d,h,u+1)}(e,0,2*Math.PI,0),r}cutByPlane(e,s,r){const i=e.geometry,a=i.attributes.position.array,c=i.attributes.normal.array,l=a.length/3;let m=l/3,p=i.getIndex();function h(e,t){const o=3*e+t;return p?p[o]:o}p&&(p=p.array,m=p.length/3);const u=[],d=[],y=this.smallDelta,V=l*l;for(let e=0;e<V;e++)this.segments[e]=!1;const f=this.tempVector3_P0,b=this.tempVector3_P1,g=this.tempVector3_N0,P=this.tempVector3_N1;for(let e=0;e<m-1;e++){const t=h(e,0),o=h(e,1),s=h(e,2);g.set(c[t],c[t]+1,c[t]+2);for(let n=e+1;n<m;n++){const e=h(n,0),r=h(n,1),i=h(n,2);P.set(c[e],c[e]+1,c[e]+2),1-g.dot(P)<y&&(t===e||t===r||t===i?o===e||o===r||o===i?(this.segments[t*l+o]=!0,this.segments[o*l+t]=!0):(this.segments[s*l+t]=!0,this.segments[t*l+s]=!0):o!==e&&o!==r&&o!==i||(this.segments[s*l+o]=!0,this.segments[o*l+s]=!0))}}const C=this.tempPlane_Cut;e.updateMatrix(),n.transformPlaneToLocalSpace(s,e.matrix,C);for(let e=0;e<m;e++){const o=h(e,0),s=h(e,1),n=h(e,2);for(let e=0;e<3;e++){const i=0===e?o:1===e?s:n,c=0===e?s:1===e?n:o;if(this.segments[i*l+c])continue;this.segments[i*l+c]=!0,this.segments[c*l+i]=!0,f.set(a[3*i],a[3*i+1],a[3*i+2]),b.set(a[3*c],a[3*c+1],a[3*c+2]);let m=0,p=C.distanceToPoint(f);p>y?(m=2,d.push(f.clone())):p<-y?(m=1,u.push(f.clone())):(m=3,u.push(f.clone()),d.push(f.clone()));let h=0;if(p=C.distanceToPoint(b),p>y?(h=2,d.push(b.clone())):p<-y?(h=1,u.push(b.clone())):(h=3,u.push(b.clone()),d.push(b.clone())),1===m&&2===h||2===m&&1===h){this.tempLine1.start.copy(f),this.tempLine1.end.copy(b);let e=new t.Vector3;if(e=C.intersectLine(this.tempLine1,e),null===e)return console.error("Internal error: segment does not intersect plane."),r.segmentedObject1=null,r.segmentedObject2=null,0;u.push(e),d.push(e.clone())}}}const M=.5*e.userData.mass;this.tempCM1.set(0,0,0);let x=0;const _=u.length;if(_>0){for(let e=0;e<_;e++)this.tempCM1.add(u[e]);this.tempCM1.divideScalar(_);for(let e=0;e<_;e++){const t=u[e];t.sub(this.tempCM1),x=Math.max(x,t.x,t.y,t.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let j=0;const w=d.length;if(w>0){for(let e=0;e<w;e++)this.tempCM2.add(d[e]);this.tempCM2.divideScalar(w);for(let e=0;e<w;e++){const t=d[e];t.sub(this.tempCM2),j=Math.max(j,t.x,t.y,t.z)}this.tempCM2.add(e.position)}let v=null,B=null,T=0;return _>4&&(v=new t.Mesh(new o.ConvexGeometry(u),e.material),v.position.copy(this.tempCM1),v.quaternion.copy(e.quaternion),this.prepareBreakableObject(v,M,e.userData.velocity,e.userData.angularVelocity,2*x>this.minSizeForBreak),T++),w>4&&(B=new t.Mesh(new o.ConvexGeometry(d),e.material),B.position.copy(this.tempCM2),B.quaternion.copy(e.quaternion),this.prepareBreakableObject(B,M,e.userData.velocity,e.userData.angularVelocity,2*j>this.minSizeForBreak),T++),r.object1=v,r.object2=B,T}static transformFreeVector(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[4]*s+r[8]*n,e.y=r[1]*o+r[5]*s+r[9]*n,e.z=r[2]*o+r[6]*s+r[10]*n,e}static transformFreeVectorInverse(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[1]*s+r[2]*n,e.y=r[4]*o+r[5]*s+r[6]*n,e.z=r[8]*o+r[9]*s+r[10]*n,e}static transformTiedVectorInverse(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[1]*s+r[2]*n-r[12],e.y=r[4]*o+r[5]*s+r[6]*n-r[13],e.z=r[8]*o+r[9]*s+r[10]*n-r[14],e}static transformPlaneToLocalSpace(e,t,o){o.normal.copy(e.normal),o.constant=e.constant;const r=n.transformTiedVectorInverse(e.coplanarPoint(s),t);n.transformFreeVectorInverse(o.normal,t),o.constant=-r.dot(o.normal)}}e.ConvexObjectBreaker=n,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("../geometries/ConvexGeometry.js")):"function"==typeof define&&define.amd?define(["exports","three","../geometries/ConvexGeometry"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE)}();
