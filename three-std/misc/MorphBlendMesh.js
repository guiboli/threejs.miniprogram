!function(){var t,i;t=this,i=function(t,i){"use strict";class n extends i.Mesh{constructor(t,i){super(t,i),this.animationsMap={},this.animationsList=[];const n=Object.keys(this.morphTargetDictionary).length,e="__default",a=n-1,s=n/1;this.createAnimation(e,0,a,s),this.setAnimationWeight(e,1)}createAnimation(t,i,n,e){const a={start:i,end:n,length:n-i+1,fps:e,duration:(n-i)/e,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[t]=a,this.animationsList.push(a)}autoCreateAnimations(t){const i=/([a-z]+)_?(\d+)/i;let n;const e={};let a=0;for(const t in this.morphTargetDictionary){const s=t.match(i);if(s&&s.length>1){const t=s[1];e[t]||(e[t]={start:1/0,end:-1/0});const i=e[t];a<i.start&&(i.start=a),a>i.end&&(i.end=a),n||(n=t)}a++}for(const i in e){const n=e[i];this.createAnimation(i,n.start,n.end,t)}this.firstAnimation=n}setAnimationDirectionForward(t){const i=this.animationsMap[t];i&&(i.direction=1,i.directionBackwards=!1)}setAnimationDirectionBackward(t){const i=this.animationsMap[t];i&&(i.direction=-1,i.directionBackwards=!0)}setAnimationFPS(t,i){const n=this.animationsMap[t];n&&(n.fps=i,n.duration=(n.end-n.start)/n.fps)}setAnimationDuration(t,i){const n=this.animationsMap[t];n&&(n.duration=i,n.fps=(n.end-n.start)/n.duration)}setAnimationWeight(t,i){const n=this.animationsMap[t];n&&(n.weight=i)}setAnimationTime(t,i){const n=this.animationsMap[t];n&&(n.time=i)}getAnimationTime(t){let i=0;const n=this.animationsMap[t];return n&&(i=n.time),i}getAnimationDuration(t){let i=-1;const n=this.animationsMap[t];return n&&(i=n.duration),i}playAnimation(t){const i=this.animationsMap[t];i?(i.time=0,i.active=!0):console.warn("THREE.MorphBlendMesh: animation["+t+"] undefined in .playAnimation()")}stopAnimation(t){const i=this.animationsMap[t];i&&(i.active=!1)}update(t){for(let n=0,e=this.animationsList.length;n<e;n++){const e=this.animationsList[n];if(!e.active)continue;const a=e.duration/e.length;e.time+=e.direction*t,e.mirroredLoop?(e.time>e.duration||e.time<0)&&(e.direction*=-1,e.time>e.duration&&(e.time=e.duration,e.directionBackwards=!0),e.time<0&&(e.time=0,e.directionBackwards=!1)):(e.time=e.time%e.duration,e.time<0&&(e.time+=e.duration));const s=e.start+i.MathUtils.clamp(Math.floor(e.time/a),0,e.length-1),o=e.weight;s!==e.currentFrame&&(this.morphTargetInfluences[e.lastFrame]=0,this.morphTargetInfluences[e.currentFrame]=1*o,this.morphTargetInfluences[s]=0,e.lastFrame=e.currentFrame,e.currentFrame=s);let r=e.time%a/a;e.directionBackwards&&(r=1-r),e.currentFrame!==e.lastFrame?(this.morphTargetInfluences[e.currentFrame]=r*o,this.morphTargetInfluences[e.lastFrame]=(1-r)*o):this.morphTargetInfluences[e.currentFrame]=o}}}t.MorphBlendMesh=n,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE)}();
