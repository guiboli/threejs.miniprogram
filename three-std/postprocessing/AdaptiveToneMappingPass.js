!function(){var e,t;e=this,t=function(e,t,i,a,n,r){"use strict";class s extends i.Pass{constructor(e,s){super(),this.resolution=void 0!==s?s:256,this.needsInit=!0,this.adaptive=void 0===e||!!e,this.luminanceRT=null,this.previousLuminanceRT=null,this.currentLuminanceRT=null,void 0===a.CopyShader&&console.error("THREE.AdaptiveToneMappingPass relies on CopyShader");const u=a.CopyShader;this.copyUniforms=t.UniformsUtils.clone(u.uniforms),this.materialCopy=new t.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:t.NoBlending,depthTest:!1}),void 0===n.LuminosityShader&&console.error("THREE.AdaptiveToneMappingPass relies on LuminosityShader"),this.materialLuminance=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(n.LuminosityShader.uniforms),vertexShader:n.LuminosityShader.vertexShader,fragmentShader:n.LuminosityShader.fragmentShader,blending:t.NoBlending}),this.adaptLuminanceShader={defines:{MIP_LEVEL_1X1:(Math.log(this.resolution)/Math.log(2)).toFixed(1)},uniforms:{lastLum:{value:null},currentLum:{value:null},minLuminance:{value:.01},delta:{value:.016},tau:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}"},this.materialAdaptiveLum=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),vertexShader:this.adaptLuminanceShader.vertexShader,fragmentShader:this.adaptLuminanceShader.fragmentShader,defines:Object.assign({},this.adaptLuminanceShader.defines),blending:t.NoBlending}),void 0===r.ToneMapShader&&console.error("THREE.AdaptiveToneMappingPass relies on ToneMapShader"),this.materialToneMap=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(r.ToneMapShader.uniforms),vertexShader:r.ToneMapShader.vertexShader,fragmentShader:r.ToneMapShader.fragmentShader,blending:t.NoBlending}),this.fsQuad=new i.FullScreenQuad(null)}render(e,t,i,a){this.needsInit&&(this.reset(e),this.luminanceRT.texture.type=i.texture.type,this.previousLuminanceRT.texture.type=i.texture.type,this.currentLuminanceRT.texture.type=i.texture.type,this.needsInit=!1),this.adaptive&&(this.fsQuad.material=this.materialLuminance,this.materialLuminance.uniforms.tDiffuse.value=i.texture,e.setRenderTarget(this.currentLuminanceRT),this.fsQuad.render(e),this.fsQuad.material=this.materialAdaptiveLum,this.materialAdaptiveLum.uniforms.delta.value=a,this.materialAdaptiveLum.uniforms.lastLum.value=this.previousLuminanceRT.texture,this.materialAdaptiveLum.uniforms.currentLum.value=this.currentLuminanceRT.texture,e.setRenderTarget(this.luminanceRT),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.luminanceRT.texture,e.setRenderTarget(this.previousLuminanceRT),this.fsQuad.render(e)),this.fsQuad.material=this.materialToneMap,this.materialToneMap.uniforms.tDiffuse.value=i.texture,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this.fsQuad.render(e))}reset(){this.luminanceRT&&this.luminanceRT.dispose(),this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),this.previousLuminanceRT&&this.previousLuminanceRT.dispose();const e={minFilter:t.LinearFilter,magFilter:t.LinearFilter,format:t.RGBAFormat};this.luminanceRT=new t.WebGLRenderTarget(this.resolution,this.resolution,e),this.luminanceRT.texture.name="AdaptiveToneMappingPass.l",this.luminanceRT.texture.generateMipmaps=!1,this.previousLuminanceRT=new t.WebGLRenderTarget(this.resolution,this.resolution,e),this.previousLuminanceRT.texture.name="AdaptiveToneMappingPass.pl",this.previousLuminanceRT.texture.generateMipmaps=!1,e.minFilter=t.LinearMipmapLinearFilter,e.generateMipmaps=!0,this.currentLuminanceRT=new t.WebGLRenderTarget(this.resolution,this.resolution,e),this.currentLuminanceRT.texture.name="AdaptiveToneMappingPass.cl",this.adaptive&&(this.materialToneMap.defines.ADAPTED_LUMINANCE="",this.materialToneMap.uniforms.luminanceMap.value=this.luminanceRT.texture),this.fsQuad.material=new t.MeshBasicMaterial({color:7829367}),this.materialLuminance.needsUpdate=!0,this.materialAdaptiveLum.needsUpdate=!0,this.materialToneMap.needsUpdate=!0}setAdaptive(e){e?(this.adaptive=!0,this.materialToneMap.defines.ADAPTED_LUMINANCE="",this.materialToneMap.uniforms.luminanceMap.value=this.luminanceRT.texture):(this.adaptive=!1,delete this.materialToneMap.defines.ADAPTED_LUMINANCE,this.materialToneMap.uniforms.luminanceMap.value=null),this.materialToneMap.needsUpdate=!0}setAdaptionRate(e){e&&(this.materialAdaptiveLum.uniforms.tau.value=Math.abs(e))}setMinLuminance(e){e&&(this.materialToneMap.uniforms.minLuminance.value=e,this.materialAdaptiveLum.uniforms.minLuminance.value=e)}setMaxLuminance(e){e&&(this.materialToneMap.uniforms.maxLuminance.value=e)}setAverageLuminance(e){e&&(this.materialToneMap.uniforms.averageLuminance.value=e)}setMiddleGrey(e){e&&(this.materialToneMap.uniforms.middleGrey.value=e)}dispose(){this.luminanceRT&&this.luminanceRT.dispose(),this.previousLuminanceRT&&this.previousLuminanceRT.dispose(),this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),this.materialLuminance&&this.materialLuminance.dispose(),this.materialAdaptiveLum&&this.materialAdaptiveLum.dispose(),this.materialCopy&&this.materialCopy.dispose(),this.materialToneMap&&this.materialToneMap.dispose()}}e.AdaptiveToneMappingPass=s,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("./Pass.js"),require("../shaders/CopyShader.js"),require("../shaders/LuminosityShader.js"),require("../shaders/ToneMapShader.js")):"function"==typeof define&&define.amd?define(["exports","three","./Pass","../shaders/CopyShader","../shaders/LuminosityShader","../shaders/ToneMapShader"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE,e.THREE,e.THREE,e.THREE)}();
