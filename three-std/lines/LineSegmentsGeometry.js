!function(){var t,e;t=this,e=function(t,e){"use strict";const n=new e.Box3,r=new e.Vector3;class i extends e.InstancedBufferGeometry{constructor(){super(),this.type="LineSegmentsGeometry",this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new e.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new e.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const r=new e.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceStart",new e.InterleavedBufferAttribute(r,3,0)),this.setAttribute("instanceEnd",new e.InterleavedBufferAttribute(r,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const r=new e.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceColorStart",new e.InterleavedBufferAttribute(r,3,0)),this.setAttribute("instanceColorEnd",new e.InterleavedBufferAttribute(r,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new e.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new e.Box3);const t=this.attributes.instanceStart,r=this.attributes.instanceEnd;void 0!==t&&void 0!==r&&(this.boundingBox.setFromBufferAttribute(t),n.setFromBufferAttribute(r),this.boundingBox.union(n))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new e.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==t&&void 0!==n){const e=this.boundingSphere.center;this.boundingBox.getCenter(e);let i=0;for(let o=0,s=t.count;o<s;o++)r.fromBufferAttribute(t,o),i=Math.max(i,e.distanceToSquared(r)),r.fromBufferAttribute(n,o),i=Math.max(i,e.distanceToSquared(r));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}i.prototype.isLineSegmentsGeometry=!0,t.LineSegmentsGeometry=i,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE)}();
