!function(){var e,t;e=this,t=function(e,t){"use strict";function r(e){let r,o,n,i=0;for(let t=0;t<e.length;++t){const s=e[t];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=s.array.constructor),r!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===o&&(o=s.itemSize),o!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=s.normalized),n!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=s.array.length}const s=new r(i);let u=0;for(let t=0;t<e.length;++t)s.set(e[t].array,u),u+=e[t].array.length;return new t.BufferAttribute(s,o,n)}e.computeMorphedAttributes=function(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const r=new t.Vector3,o=new t.Vector3,n=new t.Vector3,i=new t.Vector3,s=new t.Vector3,u=new t.Vector3,a=new t.Vector3,f=new t.Vector3,l=new t.Vector3;function m(e,t,m,c,g,d,h,b,p){r.fromBufferAttribute(m,d),o.fromBufferAttribute(m,h),n.fromBufferAttribute(m,b);const y=e.morphTargetInfluences;if(t.morphTargets&&c&&y){a.set(0,0,0),f.set(0,0,0),l.set(0,0,0);for(let e=0,t=c.length;e<t;e++){const t=y[e],m=c[e];0!==t&&(i.fromBufferAttribute(m,d),s.fromBufferAttribute(m,h),u.fromBufferAttribute(m,b),g?(a.addScaledVector(i,t),f.addScaledVector(s,t),l.addScaledVector(u,t)):(a.addScaledVector(i.sub(r),t),f.addScaledVector(s.sub(o),t),l.addScaledVector(u.sub(n),t)))}r.add(a),o.add(f),n.add(l)}e.isSkinnedMesh&&(e.boneTransform(d,r),e.boneTransform(h,o),e.boneTransform(b,n)),p[3*d+0]=r.x,p[3*d+1]=r.y,p[3*d+2]=r.z,p[3*h+0]=o.x,p[3*h+1]=o.y,p[3*h+2]=o.z,p[3*b+0]=n.x,p[3*b+1]=n.y,p[3*b+2]=n.z}const c=e.geometry,g=e.material;let d,h,b;const p=c.index,y=c.attributes.position,A=c.morphAttributes.position,B=c.morphTargetsRelative,E=c.attributes.normal,T=c.morphAttributes.position,w=c.groups,x=c.drawRange;let G,R,S,M,U,v,z,H;const X=new Float32Array(y.count*y.itemSize),D=new Float32Array(E.count*E.itemSize);if(null!==p)if(Array.isArray(g))for(G=0,S=w.length;G<S;G++)for(U=w[G],v=g[U.materialIndex],z=Math.max(U.start,x.start),H=Math.min(U.start+U.count,x.start+x.count),R=z,M=H;R<M;R+=3)d=p.getX(R),h=p.getX(R+1),b=p.getX(R+2),m(e,v,y,A,B,d,h,b,X),m(e,v,E,T,B,d,h,b,D);else for(z=Math.max(0,x.start),H=Math.min(p.count,x.start+x.count),G=z,S=H;G<S;G+=3)d=p.getX(G),h=p.getX(G+1),b=p.getX(G+2),m(e,g,y,A,B,d,h,b,X),m(e,g,E,T,B,d,h,b,D);else if(Array.isArray(g))for(G=0,S=w.length;G<S;G++)for(U=w[G],v=g[U.materialIndex],z=Math.max(U.start,x.start),H=Math.min(U.start+U.count,x.start+x.count),R=z,M=H;R<M;R+=3)d=R,h=R+1,b=R+2,m(e,v,y,A,B,d,h,b,X),m(e,v,E,T,B,d,h,b,D);else for(z=Math.max(0,x.start),H=Math.min(y.count,x.start+x.count),G=z,S=H;G<S;G+=3)d=G,h=G+1,b=G+2,m(e,g,y,A,B,d,h,b,X),m(e,g,E,T,B,d,h,b,D);return{positionAttribute:y,normalAttribute:E,morphedPositionAttribute:new t.Float32BufferAttribute(X,3),morphedNormalAttribute:new t.Float32BufferAttribute(D,3)}},e.computeTangents=function(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")},e.estimateBytesUsed=function(e){let t=0;for(const r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t},e.interleaveAttributes=function(e){let r,o=0,n=0;for(let t=0,i=e.length;t<i;++t){const i=e[t];if(void 0===r&&(r=i.array.constructor),r!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;o+=i.array.length,n+=i.itemSize}const i=new t.InterleavedBuffer(new r(o),n);let s=0;const u=[],a=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let r=0,o=e.length;r<o;r++){const o=e[r],n=o.itemSize,l=o.count,m=new t.InterleavedBufferAttribute(i,n,s,o.normalized);u.push(m),s+=n;for(let e=0;e<l;e++)for(let t=0;t<n;t++)m[f[t]](e,o[a[t]](e))}return u},e.mergeBufferAttributes=r,e.mergeBufferGeometries=function(e,o=!1){const n=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),s=new Set(Object.keys(e[0].morphAttributes)),u={},a={},f=e[0].morphTargetsRelative,l=new t.BufferGeometry;let m=0;for(let t=0;t<e.length;++t){const r=e[t];let c=0;if(n!==(null!==r.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in r.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[e]&&(u[e]=[]),u[e].push(r.attributes[e]),c++}if(c!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(f!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in r.morphAttributes){if(!s.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[e]&&(a[e]=[]),a[e].push(r.morphAttributes[e])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(r.userData),o){let e;if(n)e=r.index.count;else{if(void 0===r.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;e=r.attributes.position.count}l.addGroup(m,e,t),m+=e}}if(n){let t=0;const r=[];for(let o=0;o<e.length;++o){const n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}l.setIndex(r)}for(const e in u){const t=r(u[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;l.setAttribute(e,t)}for(const e in a){const t=a[e][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[e]=[];for(let o=0;o<t;++o){const t=[];for(let r=0;r<a[e].length;++r)t.push(a[e][r][o]);const n=r(t);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;l.morphAttributes[e].push(n)}}return l},e.mergeVertices=function(e,r=1e-4){r=Math.max(r,Number.EPSILON);const o={},n=e.getIndex(),i=e.getAttribute("position"),s=n?n.count:i.count;let u=0;const a=Object.keys(e.attributes),f={},l={},m=[],c=["getX","getY","getZ","getW"];for(let t=0,r=a.length;t<r;t++){const r=a[t];f[r]=[];const o=e.morphAttributes[r];o&&(l[r]=new Array(o.length).fill().map((()=>[])))}const g=Math.log10(1/r),d=Math.pow(10,g);for(let t=0;t<s;t++){const r=n?n.getX(t):t;let i="";for(let t=0,o=a.length;t<o;t++){const o=a[t],n=e.getAttribute(o),s=n.itemSize;for(let e=0;e<s;e++)i+=~~(n[c[e]](r)*d)+","}if(i in o)m.push(o[i]);else{for(let t=0,o=a.length;t<o;t++){const o=a[t],n=e.getAttribute(o),i=e.morphAttributes[o],s=n.itemSize,u=f[o],m=l[o];for(let e=0;e<s;e++){const t=c[e];if(u.push(n[t](r)),i)for(let e=0,o=i.length;e<o;e++)m[e].push(i[e][t](r))}}o[i]=u,m.push(u),u++}}const h=e.clone();for(let r=0,o=a.length;r<o;r++){const o=a[r],n=e.getAttribute(o),i=new n.array.constructor(f[o]),s=new t.BufferAttribute(i,n.itemSize,n.normalized);if(h.setAttribute(o,s),o in l)for(let r=0;r<l[o].length;r++){const n=e.morphAttributes[o][r],i=new n.array.constructor(l[o][r]),s=new t.BufferAttribute(i,n.itemSize,n.normalized);h.morphAttributes[o][r]=s}}return h.setIndex(m),h},e.toTrianglesDrawMode=function(e,r){if(r===t.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r===t.TriangleFanDrawMode||r===t.TriangleStripDrawMode){let o=e.getIndex();if(null===o){const t=[],r=e.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<r.count;e++)t.push(e);e.setIndex(t),o=e.getIndex()}const n=o.count-2,i=[];if(r===t.TriangleFanDrawMode)for(let e=1;e<=n;e++)i.push(o.getX(0)),i.push(o.getX(e)),i.push(o.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(i.push(o.getX(e)),i.push(o.getX(e+1)),i.push(o.getX(e+2))):(i.push(o.getX(e+2)),i.push(o.getX(e+1)),i.push(o.getX(e)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=e.clone();return s.setIndex(i),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
