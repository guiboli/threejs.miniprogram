!function(){var t,e;t=this,e=function(t,e,r){"use strict";t.LDrawUtils=class{static mergeObject(t){function i(t,r,i,o){const n=new e.BufferGeometry,a=t.getAttribute("position").array,s=3===i?t.getAttribute("normal").array:null,u=Math.min(r.count,Math.floor(a.length/3)-r.start),l=3*r.start,f=3*(r.start+u),c=a.subarray(l,f),m=null!==s?s.subarray(l,f):null;if(n.setAttribute("position",new e.BufferAttribute(c,3)),null!==m&&n.setAttribute("normal",new e.BufferAttribute(m,3)),o){const r=t.getAttribute("control0").array.subarray(l,f),i=t.getAttribute("control1").array.subarray(l,f),o=t.getAttribute("direction").array.subarray(l,f);n.setAttribute("control0",new e.BufferAttribute(r,3,!1)),n.setAttribute("control1",new e.BufferAttribute(i,3,!1)),n.setAttribute("direction",new e.BufferAttribute(o,3,!1))}return n}function o(t,e,r){const i=r[t.uuid];i?i.arr.push(e):r[t.uuid]={mat:t,arr:[e]}}function n(t,e){if(!t)return;const r=t.array,i=Math.floor(r.length/3);let o=0;for(let t=0;t<i;t++){const t=r[o],i=r[o+1],n=r[o+2];r[o]=r[o+3],r[o+1]=r[o+4],r[o+2]=r[o+5],r[o+3]=t,r[o+4]=i,r[o+5]=n,o+=3*e}}const a={},s={},u={};t.updateMatrixWorld(!0);const l=new e.Matrix3;t.traverse((t=>{if(t.isMesh|t.isLineSegments){const e=t.isMesh?3:2,r=t.geometry.clone();t.matrixWorld.determinant()<0&&(n(r.attributes.position,e),n(r.attributes.normal,e)),r.applyMatrix4(t.matrixWorld),t.isConditionalLine&&(r.attributes.control0.applyMatrix4(t.matrixWorld),r.attributes.control1.applyMatrix4(t.matrixWorld),l.getNormalMatrix(t.matrixWorld),r.attributes.direction.applyNormalMatrix(l));const f=t.isMesh?a:t.isConditionalLine?u:s;if(Array.isArray(t.material))for(const n in r.groups){const a=r.groups[n];o(t.material[a.materialIndex],i(r,a,e,t.isConditionalLine),f)}else o(t.material,r,f)}}));const f=new e.Group,c=Object.keys(a);for(const t of c){const i=a[t],o=r.mergeBufferGeometries(i.arr);f.add(new e.Mesh(o,i.mat))}const m=Object.keys(s);for(const t of m){const i=s[t],o=r.mergeBufferGeometries(i.arr);f.add(new e.LineSegments(o,i.mat))}const d=Object.keys(u);for(const t of d){const i=u[t],o=r.mergeBufferGeometries(i.arr),n=new e.LineSegments(o,i.mat);n.isConditionalLine=!0,f.add(n)}return f.userData.constructionStep=0,f.userData.numConstructionSteps=1,f}},Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("./BufferGeometryUtils.js")):"function"==typeof define&&define.amd?define(["exports","three","./BufferGeometryUtils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE,t.THREE)}();
