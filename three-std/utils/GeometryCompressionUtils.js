!function(){var e,t;e=this,t=function(e,t,r){"use strict";function n(e,t,r,n){if(1==n){const n=Math.round(.5*(e+1)*255),a=Math.round(.5*(t+1)*255),o=Math.round(.5*(r+1)*255);return new Uint8Array([n,a,o])}if(2==n){const n=Math.round(.5*(e+1)*65535),a=Math.round(.5*(t+1)*65535),o=Math.round(.5*(r+1)*65535);return new Uint16Array([n,a,o])}console.error("number of bytes must be 1 or 2")}function a(e,t,r){const n=parseInt(.5*(1+Math.atan2(t,e)/Math.PI)*65535),a=parseInt(.5*(1+r)*65535);return new Uint16Array([n,a])}function o(e,t,r,n){let a,o,i,s,l;return i=a=m(e,t,r,"floor","floor"),o=u(a),l=c(e,t,r,o),a=m(e,t,r,"ceil","floor"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"floor","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"ceil","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a),i;function m(e,t,a,o,i){let s=e/(Math.abs(e)+Math.abs(t)+Math.abs(a)),l=t/(Math.abs(e)+Math.abs(t)+Math.abs(a));if(r<0){const e=(1-Math.abs(l))*(s>=0?1:-1),t=(1-Math.abs(s))*(l>=0?1:-1);s=e,l=t;let r=1-Math.abs(s)-Math.abs(l);r>0&&(r+=.001,s+=s>0?r/2:-r/2,l+=l>0?r/2:-r/2)}return 1==n?new Int8Array([Math[o](127.5*s+(s<0?1:0)),Math[i](127.5*l+(l<0?1:0))]):2==n?new Int16Array([Math[o](32767.5*s+(s<0?1:0)),Math[i](32767.5*l+(l<0?1:0))]):void 0}function u(e){let t=e[0],r=e[1];1==n?(t/=t<0?127:128,r/=r<0?127:128):2==n&&(t/=t<0?32767:32768,r/=r<0?32767:32768);const a=1-Math.abs(t)-Math.abs(r);if(a<0){const e=t;t=(1-Math.abs(r))*(t>=0?1:-1),r=(1-Math.abs(e))*(r>=0?1:-1)}const o=Math.sqrt(t*t+r*r+a*a);return[t/o,r/o,a/o]}function c(e,t,r,n){return e*n[0]+t*n[1]+r*n[2]}}e.compressNormals=function(e,i){e.geometry||console.error("Mesh must contain geometry. ");const s=e.geometry.attributes.normal;if(s||console.error("Geometry must contain normal attribute. "),s.isPacked)return;3!=s.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");const l=s.array,m=s.count;let u;if("DEFAULT"==i){u=new Uint8Array(3*m);for(let e=0;e<l.length;e+=3){const t=n(l[e],l[e+1],l[e+2],1);u[e+0]=t[0],u[e+1]=t[1],u[e+2]=t[2]}e.geometry.setAttribute("normal",new t.BufferAttribute(u,3,!0)),e.geometry.attributes.normal.bytes=1*u.length}else if("OCT1Byte"==i){u=new Int8Array(2*m);for(let e=0;e<l.length;e+=3){const t=o(l[e],l[e+1],l[e+2],1);u[e/3*2+0]=t[0],u[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(u,2,!0)),e.geometry.attributes.normal.bytes=1*u.length}else if("OCT2Byte"==i){u=new Int16Array(2*m);for(let e=0;e<l.length;e+=3){const t=o(l[e],l[e+1],l[e+2],2);u[e/3*2+0]=t[0],u[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(u,2,!0)),e.geometry.attributes.normal.bytes=2*u.length}else if("ANGLES"==i){u=new Uint16Array(2*m);for(let e=0;e<l.length;e+=3){const t=a(l[e],l[e+1],l[e+2]);u[e/3*2+0]=t[0],u[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(u,2,!0)),e.geometry.attributes.normal.bytes=2*u.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");e.geometry.attributes.normal.needsUpdate=!0,e.geometry.attributes.normal.isPacked=!0,e.geometry.attributes.normal.packingMethod=i,e.material instanceof r.PackedPhongMaterial||(e.material=(new r.PackedPhongMaterial).copy(e.material)),"ANGLES"==i&&(e.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==i&&(e.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==i&&(e.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==i&&(e.material.defines.USE_PACKED_NORMAL=2)},e.compressPositions=function(e){e.geometry||console.error("Mesh must contain geometry. ");const n=e.geometry.attributes.position;if(n||console.error("Geometry must contain position attribute. "),n.isPacked)return;3!=n.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");const a=function(e,r){let n,a;1==r?(n=new Uint8Array(e.length),a=255):2==r?(n=new Uint16Array(e.length),a=65535):console.error("number of bytes error! ");const o=new t.Matrix4,i=new Float32Array(3),s=new Float32Array(3);i[0]=i[1]=i[2]=Number.MAX_VALUE,s[0]=s[1]=s[2]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=3)i[0]=Math.min(i[0],e[t+0]),i[1]=Math.min(i[1],e[t+1]),i[2]=Math.min(i[2],e[t+2]),s[0]=Math.max(s[0],e[t+0]),s[1]=Math.max(s[1],e[t+1]),s[2]=Math.max(s[2],e[t+2]);o.scale(new t.Vector3((s[0]-i[0])/a,(s[1]-i[1])/a,(s[2]-i[2])/a)),o.elements[12]=i[0],o.elements[13]=i[1],o.elements[14]=i[2],o.transpose();const l=new Float32Array([s[0]!==i[0]?a/(s[0]-i[0]):0,s[1]!==i[1]?a/(s[1]-i[1]):0,s[2]!==i[2]?a/(s[2]-i[2]):0]);for(let t=0;t<e.length;t+=3)n[t+0]=Math.floor((e[t+0]-i[0])*l[0]),n[t+1]=Math.floor((e[t+1]-i[1])*l[1]),n[t+2]=Math.floor((e[t+2]-i[2])*l[2]);return{quantized:n,decodeMat:o}}(n.array,2),o=a.quantized,i=a.decodeMat;null==e.geometry.boundingBox&&e.geometry.computeBoundingBox(),null==e.geometry.boundingSphere&&e.geometry.computeBoundingSphere(),e.geometry.setAttribute("position",new t.BufferAttribute(o,3)),e.geometry.attributes.position.isPacked=!0,e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.position.bytes=2*o.length,e.material instanceof r.PackedPhongMaterial||(e.material=(new r.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_POSITION=0,e.material.uniforms.quantizeMatPos.value=i,e.material.uniforms.quantizeMatPos.needsUpdate=!0},e.compressUvs=function(e){e.geometry||console.error("Mesh must contain geometry property. ");const a=e.geometry.attributes.uv;if(a||console.error("Geometry must contain uv attribute. "),a.isPacked)return;const o={min:1/0,max:-1/0},i=a.array;for(let e=0;e<i.length;e++)o.min=Math.min(o.min,i[e]),o.max=Math.max(o.max,i[e]);let s;if(o.min>=-1&&o.max<=1){s=new Uint16Array(i.length);for(let e=0;e<i.length;e+=2){const t=n(i[e],i[e+1],0,2);s[e]=t[0],s[e+1]=t[1]}e.geometry.setAttribute("uv",new t.BufferAttribute(s,2,!0)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*s.length,e.material instanceof r.PackedPhongMaterial||(e.material=(new r.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=0}else s=function(e,r){let n,a;1==r?(n=new Uint8Array(e.length),a=255):2==r?(n=new Uint16Array(e.length),a=65535):console.error("number of bytes error! ");const o=new t.Matrix3,i=new Float32Array(2),s=new Float32Array(2);i[0]=i[1]=Number.MAX_VALUE,s[0]=s[1]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=2)i[0]=Math.min(i[0],e[t+0]),i[1]=Math.min(i[1],e[t+1]),s[0]=Math.max(s[0],e[t+0]),s[1]=Math.max(s[1],e[t+1]);o.scale((s[0]-i[0])/a,(s[1]-i[1])/a),o.elements[6]=i[0],o.elements[7]=i[1],o.transpose();const l=new Float32Array([s[0]!==i[0]?a/(s[0]-i[0]):0,s[1]!==i[1]?a/(s[1]-i[1]):0]);for(let t=0;t<e.length;t+=2)n[t+0]=Math.floor((e[t+0]-i[0])*l[0]),n[t+1]=Math.floor((e[t+1]-i[1])*l[1]);return{quantized:n,decodeMat:o}}(i,2),e.geometry.setAttribute("uv",new t.BufferAttribute(s.quantized,2)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*s.quantized.length,e.material instanceof r.PackedPhongMaterial||(e.material=(new r.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=1,e.material.uniforms.quantizeMatUV.value=s.decodeMat,e.material.uniforms.quantizeMatUV.needsUpdate=!0},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("./PackedPhongMaterial.js")):"function"==typeof define&&define.amd?define(["exports","three","./PackedPhongMaterial"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE)}();
