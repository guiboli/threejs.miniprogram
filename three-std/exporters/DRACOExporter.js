!function(){var e,t;e=this,t=function(e){"use strict";class t{parse(e,o={decodeSpeed:5,encodeSpeed:5,encoderMethod:t.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1}){if(!0===e.isBufferGeometry)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");const r=e.geometry,n=DracoEncoderModule(),i=new n.Encoder;let d,s;if(!0!==r.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");if(!0===e.isMesh){d=new n.MeshBuilder,s=new n.Mesh;const e=r.getAttribute("position");d.AddFloatAttributeToMesh(s,n.POSITION,e.count,e.itemSize,e.array);const t=r.getIndex();if(null!==t)d.AddFacesToMesh(s,t.count/3,t.array);else{const t=new(e.count>65535?Uint32Array:Uint16Array)(e.count);for(let e=0;e<t.length;e++)t[e]=e;d.AddFacesToMesh(s,e.count,t)}if(!0===o.exportNormals){const e=r.getAttribute("normal");void 0!==e&&d.AddFloatAttributeToMesh(s,n.NORMAL,e.count,e.itemSize,e.array)}if(!0===o.exportUvs){const e=r.getAttribute("uv");void 0!==e&&d.AddFloatAttributeToMesh(s,n.TEX_COORD,e.count,e.itemSize,e.array)}if(!0===o.exportColor){const e=r.getAttribute("color");void 0!==e&&d.AddFloatAttributeToMesh(s,n.COLOR,e.count,e.itemSize,e.array)}}else{if(!0!==e.isPoints)throw new Error("DRACOExporter: Unsupported object type.");{d=new n.PointCloudBuilder,s=new n.PointCloud;const e=r.getAttribute("position");if(d.AddFloatAttribute(s,n.POSITION,e.count,e.itemSize,e.array),!0===o.exportColor){const e=r.getAttribute("color");void 0!==e&&d.AddFloatAttribute(s,n.COLOR,e.count,e.itemSize,e.array)}}}const a=new n.DracoInt8Array,c=void 0!==o.encodeSpeed?o.encodeSpeed:5,u=void 0!==o.decodeSpeed?o.decodeSpeed:5;if(i.SetSpeedOptions(c,u),void 0!==o.encoderMethod&&i.SetEncodingMethod(o.encoderMethod),void 0!==o.quantization)for(let e=0;e<5;e++)void 0!==o.quantization[e]&&i.SetAttributeQuantization(e,o.quantization[e]);let E;if(E=!0===e.isMesh?i.EncodeMeshToDracoBuffer(s,a):i.EncodePointCloudToDracoBuffer(s,!0,a),n.destroy(s),0===E)throw new Error("THREE.DRACOExporter: Draco encoding failed.");const f=new Int8Array(new ArrayBuffer(E));for(let e=0;e<E;e++)f[e]=a.GetValue(e);return n.destroy(a),n.destroy(i),n.destroy(d),f}}t.MESH_EDGEBREAKER_ENCODING=1,t.MESH_SEQUENTIAL_ENCODING=0,t.POINT_CLOUD=0,t.TRIANGULAR_MESH=1,t.INVALID=-1,t.POSITION=0,t.NORMAL=1,t.COLOR=2,t.TEX_COORD=3,t.GENERIC=4,e.DRACOExporter=t,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{})}();
