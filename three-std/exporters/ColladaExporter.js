!function(){var e,t;e=this,t=function(e,t){"use strict";e.ColladaExporter=class{parse(e,r,n={}){if(null===(n=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},n)).upAxis.match(/^[XYZ]_UP$/))return console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP."),null;if(null!==n.unitName&&null===n.unitMeter)return console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified."),null;if(null!==n.unitMeter&&null===n.unitName)return console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified."),null;""!==n.textureDirectory&&(n.textureDirectory=`${n.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const a=n.version;if("1.4.1"!==a&&"1.5.0"!==a)return console.warn(`ColladaExporter : Version ${a} not supported for export. Only 1.4.1 and 1.5.0.`),null;let i,o;function s(e,t){return i=i||document.createElement("canvas"),o=o||i.getContext("2d"),i.width=e.width,i.height=e.height,o.drawImage(e,0,0),function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,n=r.length;e<n;e++)r[e]=t.charCodeAt(e);return r}(i.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}const l=["getX","getY","getZ","getW"],u=new t.Color;function c(e,t=!1){if(t){const t=new Float32Array(3*e.count);for(let r=0,n=e.count;r<n;r++)u.fromBufferAttribute(e,r).convertLinearToSRGB(),t[3*r+0]=u.r,t[3*r+1]=u.g,t[3*r+2]=u.b;return t}if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize;for(let n=0,a=e.count;n<a;n++)for(let a=0;a<r;a++)t[n*r+a]=e[l[a]](n);return t}return e.array}function m(e,t,r,n,a=!1){const i=c(e,a);return`<source id="${t}"><float_array id="${t}-array" count="${i.length}">`+i.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(i.length/e.itemSize)}" stride="${e.itemSize}">`+r.map((e=>`<param name="${e}" type="${n}" />`)).join("")+"</accessor></technique_common></source>"}let f;function p(e){let t=h.get(e);if(null==t){t=`image-${y.length+1}`;const r="png",i=e.name||t;let o=`<image id="${t}" name="${i}">`;o+="1.5.0"===a?`<init_from><ref>${n.textureDirectory}${i}.${r}</ref></init_from>`:`<init_from>${n.textureDirectory}${i}.${r}</init_from>`,o+="</image>",y.push(o),h.set(e,t),g.push({directory:n.textureDirectory,name:i,ext:r,data:s(e.image,r),original:e})}return t}const d=new WeakMap,$=new WeakMap,h=new WeakMap,g=[],y=[],_=[],x=[],b=[],w=function e(r){let n=`<node name="${r.name}">`;if(n+=function(e){return e.updateMatrix(),f=f||new t.Matrix4,f.copy(e.matrix),f.transpose(),`<matrix>${f.toArray().join(" ")}</matrix>`}(r),!0===r.isMesh&&null!==r.geometry){const e=function(e){let t=d.get(e);if(!t){const i=e;if(!0!==i.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const o=`Mesh${_.length+1}`,s=i.index?i.index.count*i.index.itemSize:i.attributes.position.count,l=null!=i.groups&&0!==i.groups.length?i.groups:[{start:0,count:s,materialIndex:0}];let u=`<geometry id="${o}"${e.name?` name="${e.name}"`:""}><mesh>`;const f=`${o}-position`,p=`${o}-vertices`;u+=m(i.attributes.position,f,["X","Y","Z"],"float"),u+=`<vertices id="${p}"><input semantic="POSITION" source="#${f}" /></vertices>`;let $=`<input semantic="VERTEX" source="#${p}" offset="0" />`;if("normal"in i.attributes){const e=`${o}-normal`;u+=m(i.attributes.normal,e,["X","Y","Z"],"float"),$+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in i.attributes){const e=`${o}-texcoord`;u+=m(i.attributes.uv,e,["S","T"],"float"),$+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv2"in i.attributes){const e=`${o}-texcoord2`;u+=m(i.attributes.uv2,e,["S","T"],"float"),$+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in i.attributes){const e=`${o}-color`;u+=m(i.attributes.color,e,["R","G","B"],"float",!0),$+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let h=null;if(i.index)h=c(i.index);else{h=new Array(s);for(let e=0,t=h.length;e<t;e++)h[e]=e}for(let e=0,t=l.length;e<t;e++){const t=l[e],i=(r=h,n=t.start,a=t.count,Array.isArray(r)?r.slice(n,n+a):new r.constructor(r.buffer,n*r.BYTES_PER_ELEMENT,a)),o=i.length/3;u+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${o}">`,u+=$,u+=`<p>${i.join(" ")}</p>`,u+="</triangles>"}u+="</mesh></geometry>",_.push(u),t={meshid:o,bufferGeometry:i},d.set(e,t)}var r,n,a;return t}(r.geometry),a=e.meshid,i=e.bufferGeometry;let o,s=null;const l=r.material||new t.MeshBasicMaterial,u=Array.isArray(l)?l:[l];o=i.groups.length>u.length?new Array(i.groups.length):new Array(u.length),s=o.fill().map(((e,r)=>function(e){let r=$.get(e);if(null==r){r=`Mat${x.length+1}`;let n="phong";!0===e.isMeshLambertMaterial?n="lambert":!0===e.isMeshBasicMaterial&&(n="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));const a=e.emissive?e.emissive:new t.Color(0,0,0),i=e.color?e.color:new t.Color(0,0,0),o=e.specular?e.specular:new t.Color(1,1,1),s=e.shininess||0,l=e.reflectivity||0;a.convertLinearToSRGB(),o.convertLinearToSRGB(),i.convertLinearToSRGB();let u="";!0===e.transparent&&(u+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(u+=`<transparency><float>${e.opacity}</float></transparency>`));const c=`<technique sid="common"><${n}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==n?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${i.r} ${i.g} ${i.b} 1</color>`)+"</diffuse>":"")+("constant"!==n?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===n?`<specular><color sid="specular">${o.r} ${o.g} ${o.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${s}</float>`)+"</shininess>":"")+`<reflective><color>${i.r} ${i.g} ${i.b} 1</color></reflective>`+`<reflectivity><float>${l}</float></reflectivity>`+u+`</${n}></technique>`,m=`<effect id="${r}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${p(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${p(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${p(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${p(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+c+(e.side===t.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",f=`<material id="${r}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${r}-effect" /></material>`;b.push(f),x.push(m),$.set(e,r)}return r}(u[r%u.length]))),n+=`<instance_geometry url="#${a}">`+(s.length>0?"<bind_material><technique_common>"+s.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return r.children.forEach((t=>n+=e(t))),n+="</node>",n}(e);let v=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===a?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${a}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==n.author?`<author>${n.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+(null!==n.unitName?`<unit name="${n.unitName}" meter="${n.unitMeter}" />`:"")+`<up_axis>${n.upAxis}</up_axis></asset>`;v+=`<library_images>${y.join("")}</library_images>`,v+=`<library_effects>${x.join("")}</library_effects>`,v+=`<library_materials>${b.join("")}</library_materials>`,v+=`<library_geometries>${_.join("")}</library_geometries>`,v+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${w}</visual_scene></library_visual_scenes>`,v+='<scene><instance_visual_scene url="#Scene"/></scene>',v+="</COLLADA>";const M={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,n=/<[^>]+>[^<]*<\/[^<]+>/,a=(e,t)=>t>0?e+a(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{n.test(e)||r.test(e)||!t.test(e)||i--;const o=`${a("  ",i)}${e}`;return n.test(e)||r.test(e)||t.test(e)||i++,o})).join("\n")}(v),textures:g};return"function"==typeof r&&requestAnimationFrame((()=>r(M))),M}},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
