!function(){var e,t;e=this,t=function(e,t){"use strict";function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var o=n(t);function r(e,t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const n=1024/Math.max(e.width,e.height),o=document.createElement("canvas");o.width=e.width*Math.min(1,n),o.height=e.height*Math.min(1,n);const r=o.getContext("2d");if(r.drawImage(e,0,0,o.width,o.height),void 0!==t){const e=parseInt(t,16),n=(e>>16&255)/255,i=(e>>8&255)/255,s=(255&e)/255,a=r.getImageData(0,0,o.width,o.height),u=a.data;for(let e=0;e<u.length;e+=4)u[e+0]=u[e+0]*n,u[e+1]=u[e+1]*i,u[e+2]=u[e+2]*s;r.putImageData(a,0,0)}return o}}function i(e,t){return`(${e[t+0]}, ${e[t+1]}, ${e[t+2]}, ${e[t+3]})`}function s(e,t){if(void 0===e)return console.warn("USDZExporter: Normals missing."),Array(t).fill("(0, 0, 0)").join(", ");const n=[];for(let t=0;t<e.count;t++){const o=e.getX(t),r=e.getY(t),i=e.getZ(t);n.push(`(${o.toPrecision(7)}, ${r.toPrecision(7)}, ${i.toPrecision(7)})`)}return n.join(", ")}function a(e,t){const n="            ",o=[],r=[];function i(n,o,r){const i=n.id+(r?"_"+r.getHexString():""),s=1023===n.format;return t[i]=n,`\n        def Shader "Transform2d_${o}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${e.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${l(n.repeat)}\n            float2 inputs:translation = ${l(n.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${n.id}_${o}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${i}.${s?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${e.id}/Transform2d_${o}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`}return null!==e.map?(o.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${e.id}/Texture_${e.map.id}_diffuse.outputs:rgb>`),r.push(i(e.map,"diffuse",e.color))):o.push(`${n}color3f inputs:diffuseColor = ${u(e.color)}`),null!==e.emissiveMap?(o.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${e.id}/Texture_${e.emissiveMap.id}_emissive.outputs:rgb>`),r.push(i(e.emissiveMap,"emissive"))):e.emissive.getHex()>0&&o.push(`${n}color3f inputs:emissiveColor = ${u(e.emissive)}`),null!==e.normalMap&&(o.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${e.id}/Texture_${e.normalMap.id}_normal.outputs:rgb>`),r.push(i(e.normalMap,"normal"))),null!==e.aoMap&&(o.push(`${n}float inputs:occlusion.connect = </Materials/Material_${e.id}/Texture_${e.aoMap.id}_occlusion.outputs:r>`),r.push(i(e.aoMap,"occlusion"))),null!==e.roughnessMap&&1===e.roughness?(o.push(`${n}float inputs:roughness.connect = </Materials/Material_${e.id}/Texture_${e.roughnessMap.id}_roughness.outputs:g>`),r.push(i(e.roughnessMap,"roughness"))):o.push(`${n}float inputs:roughness = ${e.roughness}`),null!==e.metalnessMap&&1===e.metalness?(o.push(`${n}float inputs:metallic.connect = </Materials/Material_${e.id}/Texture_${e.metalnessMap.id}_metallic.outputs:b>`),r.push(i(e.metalnessMap,"metallic"))):o.push(`${n}float inputs:metallic = ${e.metalness}`),null!==e.alphaMap?(o.push(`${n}float inputs:opacity.connect = </Materials/Material_${e.id}/Texture_${e.alphaMap.id}_opacity.outputs:r>`),o.push(`${n}float inputs:opacityThreshold = 0.0001`),r.push(i(e.alphaMap,"opacity"))):o.push(`${n}float inputs:opacity = ${e.opacity}`),e.isMeshPhysicalMaterial&&(o.push(`${n}float inputs:clearcoat = ${e.clearcoat}`),o.push(`${n}float inputs:clearcoatRoughness = ${e.clearcoatRoughness}`),o.push(`${n}float inputs:ior = ${e.ior}`)),`\n    def Material "Material_${e.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${e.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${e.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${r.join("\n")}\n\n    }\n`}function u(e){return`(${e.r}, ${e.g}, ${e.b})`}function l(e){return`(${e.x}, ${e.y})`}e.USDZExporter=class{async parse(e){const t={"model.usda":null};let n='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';const u={},l={};e.traverseVisible((e=>{if(e.isMesh)if(e.material.isMeshStandardMaterial){const r=e.geometry,a=e.material,l="geometries/Geometry_"+r.id+".usd";if(!(l in t)){const e=function(e){return`\ndef "Geometry"\n{\n  ${function(e){const t="Geometry",n=e.attributes,o=n.position.count;return`\n    def Mesh "${t}"\n    {\n        int[] faceVertexCounts = [${function(e){const t=null!==e.index?e.index.count:e.attributes.position.count;return Array(t/3).fill(3).join(", ")}(e)}]\n        int[] faceVertexIndices = [${function(e){const t=e.index,n=[];if(null!==t)for(let e=0;e<t.count;e++)n.push(t.getX(e));else{const t=e.attributes.position.count;for(let e=0;e<t;e++)n.push(e)}return n.join(", ")}(e)}]\n        normal3f[] normals = [${s(n.normal,o)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${s(n.position,o)}]\n        float2[] primvars:st = [${function(e,t){if(void 0===e)return console.warn("USDZExporter: UVs missing."),Array(t).fill("(0, 0)").join(", ");const n=[];for(let t=0;t<e.count;t++){const o=e.getX(t),r=e.getY(t);n.push(`(${o.toPrecision(7)}, ${1-r.toPrecision(7)})`)}return n.join(", ")}(n.uv,o)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(e)}\n}\n`}(r);t[l]=function(e){let t='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';return t+=e,o.strToU8(t)}(e)}a.uuid in u||(u[a.uuid]=a),n+=function(e,t,n){const o="Object_"+e.id,r=function(e){const t=e.elements;return`( ${i(t,0)}, ${i(t,4)}, ${i(t,8)}, ${i(t,12)} )`}(e.matrixWorld);return e.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",e),`def Xform "${o}" (\n    prepend references = @./geometries/Geometry_${t.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${r}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n.id}>\n}\n\n`}(e,r,a)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",e)})),n+=function(e,t){const n=[];for(const o in e){const r=e[o];n.push(a(r,t))}return`def "Materials"\n{\n${n.join("")}\n}\n\n`}(u,l),t["model.usda"]=o.strToU8(n),n=null;for(const e in l){const n=l[e],o=e.split("_")[1],i=1023===n.format,s=r(n.image,o),a=await new Promise((e=>s.toBlob(e,i?"image/png":"image/jpeg",1)));t[`textures/Texture_${e}.${i?"png":"jpg"}`]=new Uint8Array(await a.arrayBuffer())}let p=0;for(const e in t){const n=t[e];p+=34+e.length;const o=63&p;if(4!==o){const r=new Uint8Array(64-o);t[e]=[n,{extra:{12345:r}}]}p=n.length}return o.zipSync(t,{level:0})}},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("../libs/fflate.module.js")):"function"==typeof define&&define.amd?define(["exports","../libs/fflate.module"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
