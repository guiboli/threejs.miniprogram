!function(){var t,e;t=this,e=function(t,e,o,r){"use strict";class n extends e.Mesh{constructor(t,a={}){super(t),this.type="Water";const l=this,i=void 0!==a.color?new e.Color(a.color):new e.Color(16777215),f=a.textureWidth||512,c=a.textureHeight||512,u=a.clipBias||0,m=a.flowDirection||new e.Vector2(1,0),v=a.flowSpeed||.03,s=a.reflectivity||.02,p=a.scale||1,d=a.shader||n.WaterShader,x=new e.TextureLoader,g=a.flowMap||void 0,h=a.normalMap0||x.load("textures/water/Water_1_M_Normal.jpg"),y=a.normalMap1||x.load("textures/water/Water_2_M_Normal.jpg"),w=.15,M=.075,R=new e.Matrix4,_=new e.Clock;if(void 0===o.Reflector)return void console.error("THREE.Water: Required component Reflector not found.");if(void 0===r.Refractor)return void console.error("THREE.Water: Required component Refractor not found.");const C=new o.Reflector(t,{textureWidth:f,textureHeight:c,clipBias:u}),E=new r.Refractor(t,{textureWidth:f,textureHeight:c,clipBias:u});C.matrixAutoUpdate=!1,E.matrixAutoUpdate=!1,this.material=new e.ShaderMaterial({uniforms:e.UniformsUtils.merge([e.UniformsLib.fog,d.uniforms]),vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,transparent:!0,fog:!0}),void 0!==g?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:g}):this.material.uniforms.flowDirection={type:"v2",value:m},h.wrapS=h.wrapT=e.RepeatWrapping,y.wrapS=y.wrapT=e.RepeatWrapping,this.material.uniforms.tReflectionMap.value=C.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=E.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=h,this.material.uniforms.tNormalMap1.value=y,this.material.uniforms.color.value=i,this.material.uniforms.reflectivity.value=s,this.material.uniforms.textureMatrix.value=R,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=M,this.material.uniforms.config.value.z=M,this.material.uniforms.config.value.w=p,this.onBeforeRender=function(t,e,o){!function(t){R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(t.projectionMatrix),R.multiply(t.matrixWorldInverse),R.multiply(l.matrixWorld)}(o),function(){const t=_.getDelta(),e=l.material.uniforms.config;e.value.x+=v*t,e.value.y=e.value.x+M,e.value.x>=w?(e.value.x=0,e.value.y=M):e.value.y>=w&&(e.value.y=e.value.y-w)}(),l.visible=!1,C.matrixWorld.copy(l.matrixWorld),E.matrixWorld.copy(l.matrixWorld),C.onBeforeRender(t,e,o),E.onBeforeRender(t,e,o),l.visible=!0}}}n.prototype.isWater=!0,n.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new e.Vector4}},vertexShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}"},t.Water=n,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("./Reflector.js"),require("./Refractor.js")):"function"==typeof define&&define.amd?define(["exports","three","./Reflector","./Refractor"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE,t.THREE,t.THREE)}();
