!function(){var e,t;e=this,t=function(e,t){"use strict";class r extends t.Mesh{constructor(e,n={}){super(e),this.type="Refractor";const o=this,a=void 0!==n.color?new t.Color(n.color):new t.Color(8355711),i=n.textureWidth||512,l=n.textureHeight||512,s=n.clipBias||0,c=n.shader||r.RefractorShader,d=void 0!==n.multisample?n.multisample:4,u=new t.PerspectiveCamera;u.matrixAutoUpdate=!1,u.userData.refractor=!0;const m=new t.Plane,f=new t.Matrix4,p=new t.WebGLRenderTarget(i,l,{samples:d});this.material=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(c.uniforms),vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,transparent:!0}),this.material.uniforms.color.value=a,this.material.uniforms.tDiffuse.value=p.texture,this.material.uniforms.textureMatrix.value=f;const v=function(){const e=new t.Vector3,r=new t.Vector3,n=new t.Matrix4,a=new t.Vector3,i=new t.Vector3;return function(t){return e.setFromMatrixPosition(o.matrixWorld),r.setFromMatrixPosition(t.matrixWorld),a.subVectors(e,r),n.extractRotation(o.matrixWorld),i.set(0,0,1),i.applyMatrix4(n),a.dot(i)<0}}(),x=function(){const e=new t.Vector3,r=new t.Vector3,n=new t.Quaternion,a=new t.Vector3;return function(){o.matrixWorld.decompose(r,n,a),e.set(0,0,1).applyQuaternion(n).normalize(),e.negate(),m.setFromNormalAndCoplanarPoint(e,r)}}(),b=function(){const e=new t.Plane,r=new t.Vector4,n=new t.Vector4;return function(t){u.matrixWorld.copy(t.matrixWorld),u.matrixWorldInverse.copy(u.matrixWorld).invert(),u.projectionMatrix.copy(t.projectionMatrix),u.far=t.far,e.copy(m),e.applyMatrix4(u.matrixWorldInverse),r.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const o=u.projectionMatrix;n.x=(Math.sign(r.x)+o.elements[8])/o.elements[0],n.y=(Math.sign(r.y)+o.elements[9])/o.elements[5],n.z=-1,n.w=(1+o.elements[10])/o.elements[14],r.multiplyScalar(2/r.dot(n)),o.elements[2]=r.x,o.elements[6]=r.y,o.elements[10]=r.z+1-s,o.elements[14]=r.w}}();this.onBeforeRender=function(e,t,r){p.texture.encoding=e.outputEncoding,!0!==r.userData.refractor&&1!=!v(r)&&(x(),function(e){f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),f.multiply(e.projectionMatrix),f.multiply(e.matrixWorldInverse),f.multiply(o.matrixWorld)}(r),b(r),function(e,t,r){o.visible=!1;const n=e.getRenderTarget(),a=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(p),!1===e.autoClear&&e.clear(),e.render(t,u),e.xr.enabled=a,e.shadowMap.autoUpdate=i,e.setRenderTarget(n);const l=r.viewport;void 0!==l&&e.state.viewport(l),o.visible=!0}(e,t,r))},this.getRenderTarget=function(){return p},this.dispose=function(){p.dispose(),o.material.dispose()}}}r.prototype.isRefractor=!0,r.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},e.Refractor=r,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
