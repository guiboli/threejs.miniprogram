!function(){var e,t;e=this,t=function(e,t){"use strict";class r extends t.Mesh{constructor(e,n={}){super(e),this.type="Reflector";const o=this,a=void 0!==n.color?new t.Color(n.color):new t.Color(8355711),l=n.textureWidth||512,i=n.textureHeight||512,s=n.clipBias||0,d=n.shader||r.ReflectorShader,u=void 0!==n.multisample?n.multisample:4,c=new t.Plane,p=new t.Vector3,f=new t.Vector3,m=new t.Vector3,x=new t.Matrix4,v=new t.Vector3(0,0,-1),b=new t.Vector4,h=new t.Vector3,g=new t.Vector3,y=new t.Vector4,M=new t.Matrix4,w=new t.PerspectiveCamera,R=new t.WebGLRenderTarget(l,i,{samples:u}),S=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(d.uniforms),fragmentShader:d.fragmentShader,vertexShader:d.vertexShader});S.uniforms.tDiffuse.value=R.texture,S.uniforms.color.value=a,S.uniforms.textureMatrix.value=M,this.material=S,this.onBeforeRender=function(e,t,r){if(f.setFromMatrixPosition(o.matrixWorld),m.setFromMatrixPosition(r.matrixWorld),x.extractRotation(o.matrixWorld),p.set(0,0,1),p.applyMatrix4(x),h.subVectors(f,m),h.dot(p)>0)return;h.reflect(p).negate(),h.add(f),x.extractRotation(r.matrixWorld),v.set(0,0,-1),v.applyMatrix4(x),v.add(m),g.subVectors(f,v),g.reflect(p).negate(),g.add(f),w.position.copy(h),w.up.set(0,1,0),w.up.applyMatrix4(x),w.up.reflect(p),w.lookAt(g),w.far=r.far,w.updateMatrixWorld(),w.projectionMatrix.copy(r.projectionMatrix),M.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),M.multiply(w.projectionMatrix),M.multiply(w.matrixWorldInverse),M.multiply(o.matrixWorld),c.setFromNormalAndCoplanarPoint(p,f),c.applyMatrix4(w.matrixWorldInverse),b.set(c.normal.x,c.normal.y,c.normal.z,c.constant);const n=w.projectionMatrix;y.x=(Math.sign(b.x)+n.elements[8])/n.elements[0],y.y=(Math.sign(b.y)+n.elements[9])/n.elements[5],y.z=-1,y.w=(1+n.elements[10])/n.elements[14],b.multiplyScalar(2/b.dot(y)),n.elements[2]=b.x,n.elements[6]=b.y,n.elements[10]=b.z+1-s,n.elements[14]=b.w,R.texture.encoding=e.outputEncoding,o.visible=!1;const a=e.getRenderTarget(),l=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(R),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,w),e.xr.enabled=l,e.shadowMap.autoUpdate=i,e.setRenderTarget(a);const d=r.viewport;void 0!==d&&e.state.viewport(d),o.visible=!0},this.getRenderTarget=function(){return R},this.dispose=function(){R.dispose(),o.material.dispose()}}}r.prototype.isReflector=!0,r.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},e.Reflector=r,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
