!function(){var t,e;t=this,e=function(t,e){"use strict";class r extends e.Mesh{constructor(t,a={}){super(t),this.type="ReflectorForSSRPass";const n=this,i=void 0!==a.color?new e.Color(a.color):new e.Color(8355711),o=a.textureWidth||512,l=a.textureHeight||512,s=a.clipBias||0,u=a.shader||r.ReflectorShader,c=!0===a.useDepthTexture,d=new e.Vector3(0,1,0),f=new e.Vector3,v=new e.Vector3;n.needsUpdate=!1,n.maxDistance=r.ReflectorShader.uniforms.maxDistance.value,n.opacity=r.ReflectorShader.uniforms.opacity.value,n.color=i,n.resolution=a.resolution||new e.Vector2(window.innerWidth,window.innerHeight),n._distanceAttenuation=r.ReflectorShader.defines.DISTANCE_ATTENUATION,Object.defineProperty(n,"distanceAttenuation",{get:()=>n._distanceAttenuation,set(t){n._distanceAttenuation!==t&&(n._distanceAttenuation=t,n.material.defines.DISTANCE_ATTENUATION=t,n.material.needsUpdate=!0)}}),n._fresnel=r.ReflectorShader.defines.FRESNEL,Object.defineProperty(n,"fresnel",{get:()=>n._fresnel,set(t){n._fresnel!==t&&(n._fresnel=t,n.material.defines.FRESNEL=t,n.material.needsUpdate=!0)}});const p=new e.Vector3,m=new e.Vector3,x=new e.Vector3,h=new e.Matrix4,w=new e.Vector3(0,0,-1),g=new e.Vector3,y=new e.Vector3,b=new e.Matrix4,M=new e.PerspectiveCamera;let C;c&&(C=new e.DepthTexture,C.type=e.UnsignedShortType,C.minFilter=e.NearestFilter,C.magFilter=e.NearestFilter);const P={depthTexture:c?C:null},T=new e.WebGLRenderTarget(o,l,P),D=new e.ShaderMaterial({transparent:c,defines:Object.assign({},r.ReflectorShader.defines,{useDepthTexture:c}),uniforms:e.UniformsUtils.clone(u.uniforms),fragmentShader:u.fragmentShader,vertexShader:u.vertexShader});D.uniforms.tDiffuse.value=T.texture,D.uniforms.color.value=n.color,D.uniforms.textureMatrix.value=b,c&&(D.uniforms.tDepth.value=T.depthTexture),this.material=D;const S=[new e.Plane(new e.Vector3(0,1,0),s)];this.doRender=function(t,e,r){if(D.uniforms.maxDistance.value=n.maxDistance,D.uniforms.color.value=n.color,D.uniforms.opacity.value=n.opacity,f.copy(r.position).normalize(),v.copy(f).reflect(d),D.uniforms.fresnelCoe.value=(f.dot(v)+1)/2,m.setFromMatrixPosition(n.matrixWorld),x.setFromMatrixPosition(r.matrixWorld),h.extractRotation(n.matrixWorld),p.set(0,0,1),p.applyMatrix4(h),g.subVectors(m,x),g.dot(p)>0)return;g.reflect(p).negate(),g.add(m),h.extractRotation(r.matrixWorld),w.set(0,0,-1),w.applyMatrix4(h),w.add(x),y.subVectors(m,w),y.reflect(p).negate(),y.add(m),M.position.copy(g),M.up.set(0,1,0),M.up.applyMatrix4(h),M.up.reflect(p),M.lookAt(y),M.far=r.far,M.updateMatrixWorld(),M.projectionMatrix.copy(r.projectionMatrix),D.uniforms.virtualCameraNear.value=r.near,D.uniforms.virtualCameraFar.value=r.far,D.uniforms.virtualCameraMatrixWorld.value=M.matrixWorld,D.uniforms.virtualCameraProjectionMatrix.value=r.projectionMatrix,D.uniforms.virtualCameraProjectionMatrixInverse.value=r.projectionMatrixInverse,D.uniforms.resolution.value=n.resolution,b.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),b.multiply(M.projectionMatrix),b.multiply(M.matrixWorldInverse),b.multiply(n.matrixWorld),T.texture.encoding=t.outputEncoding;const a=t.getRenderTarget(),i=t.xr.enabled,o=t.shadowMap.autoUpdate,l=t.clippingPlanes;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.clippingPlanes=S,t.setRenderTarget(T),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,M),t.xr.enabled=i,t.shadowMap.autoUpdate=o,t.clippingPlanes=l,t.setRenderTarget(a);const s=r.viewport;void 0!==s&&t.state.viewport(s)},this.getRenderTarget=function(){return T}}}r.prototype.isReflectorForSSRPass=!0,r.ReflectorShader={defines:{DISTANCE_ATTENUATION:!0,FRESNEL:!0},uniforms:{color:{value:null},tDiffuse:{value:null},tDepth:{value:null},textureMatrix:{value:new e.Matrix4},maxDistance:{value:180},opacity:{value:.5},fresnelCoe:{value:null},virtualCameraNear:{value:null},virtualCameraFar:{value:null},virtualCameraProjectionMatrix:{value:new e.Matrix4},virtualCameraMatrixWorld:{value:new e.Matrix4},virtualCameraProjectionMatrixInverse:{value:new e.Matrix4},resolution:{value:new e.Vector2}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t"},t.ReflectorForSSRPass=r,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE)}();
