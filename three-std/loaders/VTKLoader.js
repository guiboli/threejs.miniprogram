!function(){var t,e;t=this,e=function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var s=n(r);class o extends e.Loader{constructor(t){super(t)}load(t,r,n,s){const o=this,a=new e.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(t,(function(e){try{r(o.parse(e))}catch(e){s?s(e):console.error(e),o.manager.itemError(t)}}),n,s)}parse(t){function r(t,e){const r=t.length,n=new Float32Array(r+e.length);return n.set(t),n.set(e,r),n}function n(t,e){const r=t.length,n=new Int32Array(r+e.length);return n.set(t),n.set(e,r),n}const o=e.LoaderUtils.decodeText(new Uint8Array(t,0,250)).split("\n");return-1!==o[0].indexOf("xml")?function(t){function o(t){const e="undefined"!=typeof Uint8Array?Uint8Array:Array,r=[],n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let t=0,e=n.length;t<e;++t)r[n.charCodeAt(t)]=t;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63;const s=t.length;if(s%4>0)throw new Error("Invalid string. Length must be a multiple of 4");const o="="===t[s-2]?2:"="===t[s-1]?1:0,a=new e(3*s/4-o),l=o>0?s-4:s;let i,f,u=0;for(i=0,f=0;i<l;i+=4,f+=3){const e=r[t.charCodeAt(i)]<<18|r[t.charCodeAt(i+1)]<<12|r[t.charCodeAt(i+2)]<<6|r[t.charCodeAt(i+3)];a[u++]=(16711680&e)>>16,a[u++]=(65280&e)>>8,a[u++]=255&e}if(2===o){const e=r[t.charCodeAt(i)]<<2|r[t.charCodeAt(i+1)]>>4;a[u++]=255&e}else if(1===o){const e=r[t.charCodeAt(i)]<<10|r[t.charCodeAt(i+1)]<<4|r[t.charCodeAt(i+2)]>>2;a[u++]=e>>8&255,a[u++]=255&e}return a}function a(t,e){let a,i,f=0;if("UInt64"===l.attributes.header_type?f=8:"UInt32"===l.attributes.header_type&&(f=4),"binary"===t.attributes.format&&e){"Float32"===t.attributes.type?a=new Float32Array:"Int64"===t.attributes.type&&(a=new Int32Array);const e=o(t["#text"]);let l=e[0];for(let t=1;t<f-1;t++)l|=e[t]<<t*f;let u=(l+3)*f;u+=u%3>0?3-u%3:0;const c=[];let p=u;c.push(p);const d=3*f;for(let t=0;t<l;t++){let r=e[t*f+d];for(let n=1;n<f-1;n++)r|=e[t*f+d+n]<<8*n;p+=r,c.push(p)}for(let o=0;o<c.length-1;o++)i=s.unzlibSync(e.slice(c[o],c[o+1])).buffer,"Float32"===t.attributes.type?(i=new Float32Array(i),a=r(a,i)):"Int64"===t.attributes.type&&(i=new Int32Array(i),a=n(a,i));delete t["#text"],"Int64"===t.attributes.type&&"binary"===t.attributes.format&&(a=a.filter((function(t,e){if(e%2!=1)return!0})))}else"binary"!==t.attributes.format||e?i=t["#text"]?t["#text"].split(/\s+/).filter((function(t){if(""!==t)return t})):new Int32Array(0).buffer:(i=o(t["#text"]),i=i.slice(f).buffer),delete t["#text"],"Float32"===t.attributes.type?a=new Float32Array(i):"Int32"===t.attributes.type?a=new Int32Array(i):"Int64"===t.attributes.type&&(a=new Int32Array(i),"binary"===t.attributes.format&&(a=a.filter((function(t,e){if(e%2!=1)return!0}))));return a}const l=function t(e){let r={};if(1===e.nodeType){if(e.attributes&&e.attributes.length>0){r.attributes={};for(let t=0;t<e.attributes.length;t++){const n=e.attributes.item(t);r.attributes[n.nodeName]=n.nodeValue.trim()}}}else 3===e.nodeType&&(r=e.nodeValue.trim());if(e.hasChildNodes())for(let n=0;n<e.childNodes.length;n++){const s=e.childNodes.item(n),o=s.nodeName;if(void 0===r[o]){const e=t(s);""!==e&&(r[o]=e)}else{if(void 0===r[o].push){const t=r[o];r[o]=[t]}const e=t(s);""!==e&&r[o].push(e)}}return r}((new DOMParser).parseFromString(t,"application/xml").documentElement);let i=[],f=[],u=[];if(l.PolyData){const t=l.PolyData.Piece,r=l.attributes.hasOwnProperty("compressor"),n=["PointData","Points","Strips","Polys"];let s=0;const o=n.length;for(;s<o;){const e=t[n[s]];if(e&&e.DataArray){let o;o="[object Array]"===Object.prototype.toString.call(e.DataArray)?e.DataArray:[e.DataArray];let l=0;const c=o.length;for(;l<c;)"#text"in o[l]&&o[l]["#text"].length>0&&(o[l].text=a(o[l],r)),l++;switch(n[s]){case"PointData":{const r=parseInt(t.attributes.NumberOfPoints),n=e.attributes.Normals;if(r>0)for(let t=0,e=o.length;t<e;t++)if(n===o[t].attributes.Name){const e=o[t].attributes.NumberOfComponents;f=new Float32Array(r*e),f.set(o[t].text,0)}}break;case"Points":{const r=parseInt(t.attributes.NumberOfPoints);if(r>0){const t=e.DataArray.attributes.NumberOfComponents;i=new Float32Array(r*t),i.set(e.DataArray.text,0)}}break;case"Strips":{const r=parseInt(t.attributes.NumberOfStrips);if(r>0){const t=new Int32Array(e.DataArray[0].text.length),n=new Int32Array(e.DataArray[1].text.length);t.set(e.DataArray[0].text,0),n.set(e.DataArray[1].text,0);const s=r+t.length;u=new Uint32Array(3*s-9*r);let o=0;for(let e=0,s=r;e<s;e++){const r=[];for(let s=0,o=n[e],a=0;s<o-a;s++)r.push(t[s]),e>0&&(a=n[e-1]);for(let t=0,s=n[e],a=0;t<s-a-2;t++)t%2?(u[o++]=r[t],u[o++]=r[t+2],u[o++]=r[t+1]):(u[o++]=r[t],u[o++]=r[t+1],u[o++]=r[t+2]),e>0&&(a=n[e-1])}}}break;case"Polys":{const r=parseInt(t.attributes.NumberOfPolys);if(r>0){const t=new Int32Array(e.DataArray[0].text.length),n=new Int32Array(e.DataArray[1].text.length);t.set(e.DataArray[0].text,0),n.set(e.DataArray[1].text,0);const s=r+t.length;u=new Uint32Array(3*s-9*r);let o=0,a=0,l=0,i=0;const f=r;for(;l<f;){const e=[];let r=0;const s=n[l];for(;r<s-i;)e.push(t[a++]),r++;let f=1;for(;f<s-i-1;)u[o++]=e[0],u[o++]=e[f],u[o++]=e[f+1],f++;l++,i=n[l-1]}}}}}s++}const c=new e.BufferGeometry;return c.setIndex(new e.BufferAttribute(u,1)),c.setAttribute("position",new e.BufferAttribute(i,3)),f.length===i.length&&c.setAttribute("normal",new e.BufferAttribute(f,3)),c}throw new Error("Unsupported DATASET type")}(e.LoaderUtils.decodeText(t)):o[2].includes("ASCII")?function(t){const r=[],n=[],s=[],o=[];let a;const l=/^[^\d.\s-]+/,i=/(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g,f=/^(\d+)\s+([\s\d]*)/,u=/^POINTS /,c=/^POLYGONS /,p=/^TRIANGLE_STRIPS /,d=/^POINT_DATA[ ]+(\d+)/,A=/^CELL_DATA[ ]+(\d+)/,h=/^COLOR_SCALARS[ ]+(\w+)[ ]+3/,y=/^NORMALS[ ]+(\w+)[ ]+(\w+)/;let b=!1,x=!1,g=!1,w=!1,I=!1,m=!1,T=!1;const O=t.split("\n");for(const t in O){const e=O[t].trim();if(0===e.indexOf("DATASET")){const t=e.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(b)for(;null!==(a=i.exec(e))&&null===l.exec(e);){const t=parseFloat(a[1]),e=parseFloat(a[2]),r=parseFloat(a[3]);n.push(t,e,r)}else if(x){if(null!==(a=f.exec(e))){const t=parseInt(a[1]),e=a[2].split(/\s+/);if(t>=3){const n=parseInt(e[0]);let s=1;for(let o=0;o<t-2;++o){const t=parseInt(e[s]),o=parseInt(e[s+1]);r.push(n,t,o),s++}}}}else if(g){if(null!==(a=f.exec(e))){const t=parseInt(a[1]),e=a[2].split(/\s+/);if(t>=3)for(let n=0;n<t-2;n++)if(n%2==1){const t=parseInt(e[n]),s=parseInt(e[n+2]),o=parseInt(e[n+1]);r.push(t,s,o)}else{const t=parseInt(e[n]),s=parseInt(e[n+1]),o=parseInt(e[n+2]);r.push(t,s,o)}}}else if(w||I)if(m)for(;null!==(a=i.exec(e))&&null===l.exec(e);){const t=parseFloat(a[1]),e=parseFloat(a[2]),r=parseFloat(a[3]);s.push(t,e,r)}else if(T)for(;null!==(a=i.exec(e))&&null===l.exec(e);){const t=parseFloat(a[1]),e=parseFloat(a[2]),r=parseFloat(a[3]);o.push(t,e,r)}null!==c.exec(e)?(x=!0,b=!1,g=!1):null!==u.exec(e)?(x=!1,b=!0,g=!1):null!==p.exec(e)?(x=!1,b=!1,g=!0):null!==d.exec(e)?(w=!0,b=!1,x=!1,g=!1):null!==A.exec(e)?(I=!0,b=!1,x=!1,g=!1):null!==h.exec(e)?(m=!0,T=!1,b=!1,x=!1,g=!1):null!==y.exec(e)&&(T=!0,m=!1,b=!1,x=!1,g=!1)}let D=new e.BufferGeometry;if(D.setIndex(r),D.setAttribute("position",new e.Float32BufferAttribute(n,3)),o.length===n.length&&D.setAttribute("normal",new e.Float32BufferAttribute(o,3)),s.length!==r.length)s.length===n.length&&D.setAttribute("color",new e.Float32BufferAttribute(s,3));else{D=D.toNonIndexed();const t=D.attributes.position.count/3;if(s.length===3*t){const r=[];for(let e=0;e<t;e++){const t=s[3*e+0],n=s[3*e+1],o=s[3*e+2];r.push(t,n,o),r.push(t,n,o),r.push(t,n,o)}D.setAttribute("color",new e.Float32BufferAttribute(r,3))}}return D}(e.LoaderUtils.decodeText(t)):function(t){const r=new Uint8Array(t),n=new DataView(t);let s,o,a=[],l=[],i=[],f=0;function u(t,e){let r=e,n=t[r];const s=[];for(;10!==n;)s.push(String.fromCharCode(n)),r++,n=t[r];return{start:e,end:r,next:r+1,parsedString:s.join("")}}for(;;){if(s=u(r,f),o=s.parsedString,0===o.indexOf("DATASET")){const t=o.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(0===o.indexOf("POINTS")){const t=parseInt(o.split(" ")[1],10),e=4*t*3;a=new Float32Array(3*t);let r=s.next;for(let e=0;e<t;e++)a[3*e]=n.getFloat32(r,!1),a[3*e+1]=n.getFloat32(r+4,!1),a[3*e+2]=n.getFloat32(r+8,!1),r+=12;s.next=s.next+e+1}else if(0===o.indexOf("TRIANGLE_STRIPS")){const t=parseInt(o.split(" ")[1],10),e=parseInt(o.split(" ")[2],10),r=4*e;i=new Uint32Array(3*e-9*t);let a=0,l=s.next;for(let e=0;e<t;e++){const t=n.getInt32(l,!1),e=[];l+=4;for(let r=0;r<t;r++)e.push(n.getInt32(l,!1)),l+=4;for(let r=0;r<t-2;r++)r%2?(i[a++]=e[r],i[a++]=e[r+2],i[a++]=e[r+1]):(i[a++]=e[r],i[a++]=e[r+1],i[a++]=e[r+2])}s.next=s.next+r+1}else if(0===o.indexOf("POLYGONS")){const t=parseInt(o.split(" ")[1],10),e=parseInt(o.split(" ")[2],10),r=4*e;i=new Uint32Array(3*e-9*t);let a=0,l=s.next;for(let e=0;e<t;e++){const t=n.getInt32(l,!1),e=[];l+=4;for(let r=0;r<t;r++)e.push(n.getInt32(l,!1)),l+=4;for(let r=1;r<t-1;r++)i[a++]=e[0],i[a++]=e[r],i[a++]=e[r+1]}s.next=s.next+r+1}else if(0===o.indexOf("POINT_DATA")){const t=parseInt(o.split(" ")[1],10);s=u(r,s.next);const e=4*t*3;l=new Float32Array(3*t);let a=s.next;for(let e=0;e<t;e++)l[3*e]=n.getFloat32(a,!1),l[3*e+1]=n.getFloat32(a+4,!1),l[3*e+2]=n.getFloat32(a+8,!1),a+=12;s.next=s.next+e}if(f=s.next,f>=r.byteLength)break}const c=new e.BufferGeometry;return c.setIndex(new e.BufferAttribute(i,1)),c.setAttribute("position",new e.BufferAttribute(a,3)),l.length===a.length&&c.setAttribute("normal",new e.BufferAttribute(l,3)),c}(t)}}t.VTKLoader=o,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("../libs/fflate.module.js")):"function"==typeof define&&define.amd?define(["exports","three","../libs/fflate.module"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE,t.THREE)}();
