!function(){var t,e;t=this,e=function(t,e){"use strict";const r="16",a="24",n=new e.Vector3,o=new e.Vector3;class i extends e.ShaderMaterial{constructor(t){super({uniforms:e.UniformsUtils.merge([e.UniformsLib.fog,{diffuse:{value:new e.Color},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}class s extends e.LineSegments{constructor(t,e){super(t,e),this.isConditionalLine=!0}}const l=new e.Ray;function c(t){return"Part"===t||"Unofficial_Part"===t}class h{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getVector(){return new e.Vector3(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class d{constructor(t){this.loader=t,this._cache={}}cloneResult(t){const e={};return e.faces=t.faces.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),normals:t.normals.map((()=>null)),faceNormal:null}))),e.conditionalSegments=t.conditionalSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),controlPoints:t.controlPoints.map((t=>t.clone()))}))),e.lineSegments=t.lineSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone()))}))),e.type=t.type,e.category=t.category,e.keywords=t.keywords,e.subobjects=t.subobjects,e.totalFaces=t.totalFaces,e.startingConstructionStep=t.startingConstructionStep,e.materials=t.materials,e.group=null,e}async fetchData(t){let r=!1,a=0;for(;6!==a;){let n=t;switch(a){case 0:a+=1;break;case 1:n="parts/"+n,a+=1;break;case 2:n="p/"+n,a+=1;break;case 3:n="models/"+n,a+=1;break;case 4:n=t.substring(0,t.lastIndexOf("/")+1)+n,a+=1;break;case 5:r?a=6:(n=t=t.toLowerCase(),r=!0,a=0)}const o=this.loader,i=new e.FileLoader(o.manager);i.setPath(o.partsLibraryPath),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials);try{return await i.loadAsync(n)}catch{continue}}throw new Error('LDrawLoader: Subobject "'+t+'" could not be loaded.')}parse(t,r=null){const a=this.loader,n=[],o=[],i=[],s=[],l={},c=t=>l[t]||null;let d="Model",u=null,g=null,p=0;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const m=t.split("\n"),f=m.length;let C=!1,w=null,M=null,b=!1,y=!0,L=!1,v=!0,k=!1;for(let t=0;t<f;t++){const r=m[t];if(0===r.length)continue;if(C){r.startsWith("0 FILE ")?(this.setData(w,M),w=r.substring(7),M=""):M+=r+"\n";continue}const f=new h(r,t+1);if(f.seekNonSpace(),f.isAtTheEnd())continue;const x=f.getToken();let S,E,T,D,_,N,V,F,A,I,R;switch(x){case"0":const r=f.getToken();if(r)switch(r){case"!LDRAW_ORG":d=f.getToken();break;case"!COLOUR":S=a.parseColorMetaDirective(f),S?l[S.userData.code]=S:console.warn("LDrawLoader: Error parsing material"+f.getLineNumberString());break;case"!CATEGORY":u=f.getToken();break;case"!KEYWORDS":const e=f.getRemainingString().split(",");e.length>0&&(g||(g=[]),e.forEach((function(t){g.push(t.trim())})));break;case"FILE":t>0&&(C=!0,w=f.getRemainingString(),M="",b=!1,y=!0);break;case"BFC":for(;!f.isAtTheEnd();){const t=f.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":b="CERTIFY"===t,y=!0;break;case"CW":case"CCW":y="CCW"===t;break;case"INVERTNEXT":L=!0;break;case"CLIP":case"NOCLIP":v="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.')}}break;case"STEP":k=!0}break;case"1":E=f.getToken(),S=c(E);const h=parseFloat(f.getToken()),m=parseFloat(f.getToken()),P=parseFloat(f.getToken()),O=parseFloat(f.getToken()),z=parseFloat(f.getToken()),W=parseFloat(f.getToken()),G=parseFloat(f.getToken()),U=parseFloat(f.getToken()),j=parseFloat(f.getToken()),B=parseFloat(f.getToken()),H=parseFloat(f.getToken()),q=parseFloat(f.getToken()),$=(new e.Matrix4).set(O,z,W,h,G,U,j,m,B,H,q,P,0,0,0,1);let Y=f.getRemainingString().trim().replace(/\\/g,"/");a.fileMap[Y]?Y=a.fileMap[Y]:Y.startsWith("s/")?Y="parts/"+Y:Y.startsWith("48/")&&(Y="p/"+Y),s.push({material:S,colorCode:E,matrix:$,fileName:Y,inverted:L,startingConstructionStep:k}),L=!1;break;case"2":E=f.getToken(),S=c(E),N=f.getVector(),V=f.getVector(),T={material:S,colorCode:E,vertices:[N,V]},o.push(T);break;case"5":E=f.getToken(),S=c(E),N=f.getVector(),V=f.getVector(),I=f.getVector(),R=f.getVector(),T={material:S,colorCode:E,vertices:[N,V],controlPoints:[I,R]},i.push(T);break;case"3":E=f.getToken(),S=c(E),D=y,_=!b||!v,!0===D?(N=f.getVector(),V=f.getVector(),F=f.getVector()):(F=f.getVector(),V=f.getVector(),N=f.getVector()),n.push({material:S,colorCode:E,faceNormal:null,vertices:[N,V,F],normals:[null,null,null]}),p++,!0===_&&(n.push({material:S,colorCode:E,faceNormal:null,vertices:[F,V,N],normals:[null,null,null]}),p++);break;case"4":E=f.getToken(),S=c(E),D=y,_=!b||!v,!0===D?(N=f.getVector(),V=f.getVector(),F=f.getVector(),A=f.getVector()):(A=f.getVector(),F=f.getVector(),V=f.getVector(),N=f.getVector()),n.push({material:S,colorCode:E,faceNormal:null,vertices:[N,V,F,A],normals:[null,null,null,null]}),p+=2,!0===_&&(n.push({material:S,colorCode:E,faceNormal:null,vertices:[A,F,V,N],normals:[null,null,null,null]}),p+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+x+'"'+f.getLineNumberString()+".")}}return C&&this.setData(w,M),{faces:n,conditionalSegments:i,lineSegments:o,type:d,category:u,keywords:g,subobjects:s,totalFaces:p,startingConstructionStep:k,materials:l,fileName:r,group:null}}getData(t,e=!0){const r=t.toLowerCase(),a=this._cache[r];return null===a||a instanceof Promise?null:e?this.cloneResult(a):a}async ensureDataLoaded(t){const e=t.toLowerCase();e in this._cache||(this._cache[e]=this.fetchData(t).then((r=>{const a=this.parse(r,t);return this._cache[e]=a,a}))),await this._cache[e]}setData(t,e){const r=t.toLowerCase();this._cache[r]=this.parse(e,t)}}function u(t,e,n,o){return(!o&&t===r||o&&t===a)&&(t=e),n[t]||null}class g{constructor(t){this.loader=t,this.parseCache=new d(t),this._cache={}}async processIntoMesh(t){const i=this.loader,s=this.parseCache,c=new Set,h=async(t,n=null)=>{const o=t.subobjects,l=[];for(let t=0,e=o.length;t<e;t++){const e=o[t],r=s.ensureDataLoaded(e.fileName).then((()=>{const t=s.getData(e.fileName,!1);return r=t.type,/primitive/i.test(r)||"Subpart"===r?h(s.getData(e.fileName),e):this.loadModel(e.fileName).catch((t=>(console.warn(t),null)));var r}));l.push(r)}const d=new e.Group;d.userData.category=t.category,d.userData.keywords=t.keywords,t.group=d;const g=await Promise.all(l);for(let e=0,n=g.length;e<n;e++){const n=t.subobjects[e],o=g[e];if(null===o)continue;if(o.isGroup){const e=o;n.matrix.decompose(e.position,e.quaternion,e.scale),e.userData.startingConstructionStep=n.startingConstructionStep,e.name=n.fileName,i.applyMaterialsToMesh(e,n.colorCode,t.materials),d.add(e);continue}o.group.children.length&&d.add(o.group);const s=t.lineSegments,l=t.conditionalSegments,h=t.faces,p=o.lineSegments,m=o.conditionalSegments,f=o.faces,C=n.matrix,w=n.inverted,M=C.determinant()<0,b=n.colorCode,y=b===r?a:b;for(let e=0,r=p.length;e<r;e++){const r=p[e],n=r.vertices;n[0].applyMatrix4(C),n[1].applyMatrix4(C),r.colorCode=r.colorCode===a?y:r.colorCode,r.material=r.material||u(r.colorCode,r.colorCode,t.materials,!0),s.push(r)}for(let e=0,r=m.length;e<r;e++){const r=m[e],n=r.vertices,o=r.controlPoints;n[0].applyMatrix4(C),n[1].applyMatrix4(C),o[0].applyMatrix4(C),o[1].applyMatrix4(C),r.colorCode=r.colorCode===a?y:r.colorCode,r.material=r.material||u(r.colorCode,r.colorCode,t.materials,!0),l.push(r)}for(let e=0,a=f.length;e<a;e++){const a=f[e],n=a.vertices;for(let t=0,e=n.length;t<e;t++)n[t].applyMatrix4(C);a.colorCode=a.colorCode===r?b:a.colorCode,a.material=a.material||u(a.colorCode,b,t.materials,!1),c.add(a.colorCode),M!==w&&n.reverse(),h.push(a)}t.totalFaces+=o.totalFaces}return n&&i.applyMaterialsToMesh(d,n.colorCode,t.materials),t};for(let e=0,r=t.faces;e<r;e++)c.add(t.faces[e].colorCode);if(await h(t),i.smoothNormals){const r=c.size>1;!function(t){for(let r=0,a=t.length;r<a;r++){const a=t[r],i=a.vertices,s=i[0],l=i[1],c=i[2];n.subVectors(l,s),o.subVectors(c,l),a.faceNormal=(new e.Vector3).crossVectors(n,o).normalize()}}(t.faces),function(t,r,a=!1){const n=100*(1+1e-10);function o(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}function i(t,e){return`${o(t)}_${o(e)}`}function s(t,e,r){r.direction.subVectors(e,t).normalize();const a=t.dot(r.direction);return r.origin.copy(t).addScaledVector(r.direction,-a),r}function c(t){return i(t.origin,t.direction)}const h=new Set,d=new Map,u={},g=[];for(let t=0,n=r.length;t<n;t++){const n=r[t].vertices,o=n[0],l=n[1];if(h.add(i(o,l)),h.add(i(l,o)),a){const t=s(o,l,new e.Ray),r=c(t);if(!d.has(r)){s(l,o,t);const e=c(t),a={ray:t,distances:[]};d.set(r,a),d.set(e,a)}const a=d.get(r);let n=a.ray.direction.dot(o),i=a.ray.direction.dot(l);n>i&&([n,i]=[i,n]),a.distances.push(n,i)}}for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.vertices,o=n.length;for(let t=0;t<o;t++){const e=t,g=(t+1)%o,p=n[e],m=n[g],f=i(p,m);if(h.has(f))continue;if(a){s(p,m,l);const t=c(l);if(d.has(t)){const e=d.get(t),{ray:r,distances:a}=e;let n=r.direction.dot(p),o=r.direction.dot(m);n>o&&([n,o]=[o,n]);let i=!1;for(let t=0,e=a.length;t<e;t+=2)if(n>=a[t]&&o<=a[t+1]){i=!0;break}if(i)continue}}const C={index:e,tri:r};u[f]=C}}for(;;){let t=null;for(const e in u){t=u[e];break}if(null===t)break;const r=[t];for(;r.length>0;){const t=r.pop().tri,a=t.vertices,n=t.normals,o=t.faceNormal,s=a.length;for(let l=0;l<s;l++){const c=l,h=(l+1)%s,d=a[c],p=a[h];delete u[i(d,p)];const m=i(p,d),f=u[m];if(f){const a=f.tri,i=f.index,s=a.normals,l=s.length,d=a.faceNormal;if(Math.abs(a.faceNormal.dot(t.faceNormal))<.25)continue;m in u&&(r.push(f),delete u[m]);const p=(i+1)%l;n[c]&&s[p]&&n[c]!==s[p]&&(s[p].norm.add(n[c].norm),n[c].norm=s[p].norm);let C=n[c]||s[p];null===C&&(C={norm:new e.Vector3},g.push(C.norm)),null===n[c]&&(n[c]=C,C.norm.add(o)),null===s[p]&&(s[p]=C,C.norm.add(d)),n[h]&&s[i]&&n[h]!==s[i]&&(s[i].norm.add(n[h].norm),n[h].norm=s[i].norm);let w=n[h]||s[i];null===w&&(w={norm:new e.Vector3},g.push(w.norm)),null===n[h]&&(n[h]=w,w.norm.add(o)),null===s[i]&&(s[i]=w,w.norm.add(d))}}}}for(let t=0,e=g.length;t<e;t++)g[t].normalize()}(t.faces,t.lineSegments,r)}const d=t.group;return t.faces.length>0&&d.add(m(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&d.add(m(t.lineSegments,2)),t.conditionalSegments.length>0&&d.add(m(t.conditionalSegments,2,!0)),d}hasCachedModel(t){return null!==t&&t.toLowerCase()in this._cache}async getCachedModel(t){if(null!==t&&this.hasCachedModel(t)){const e=t.toLowerCase();return(await this._cache[e]).clone()}return null}async loadModel(t){const e=this.parseCache,r=t.toLowerCase();if(this.hasCachedModel(t))return this.getCachedModel(t);{await e.ensureDataLoaded(t);const a=e.getData(t),n=this.processIntoMesh(a);return this.hasCachedModel(t)?this.getCachedModel(t):(c(a.type)&&(this._cache[r]=n),(await n).clone())}}async parseModel(t){const e=this.parseCache.parse(t);return c(e.type)&&this.hasCachedModel(e.fileName)?this.getCachedModel(e.fileName):this.processIntoMesh(e)}}function p(t,e){return t.colorCode===e.colorCode?0:t.colorCode<e.colorCode?-1:1}function m(t,r,a=!1,i=null){t.sort(p),null===i&&(i=t.length);const l=new Float32Array(r*i*3),c=3===r?new Float32Array(r*i*3):null,h=[],d=new Array(6),u=new e.BufferGeometry;let g=null,m=0,f=0,C=0;for(let i=0,s=t.length;i<s;i++){const s=t[i];let p=s.vertices;4===p.length&&(d[0]=p[0],d[1]=p[1],d[2]=p[2],d[3]=p[0],d[4]=p[2],d[5]=p[3],p=d);for(let t=0,e=p.length;t<e;t++){const e=p[t],r=C+3*t;l[r+0]=e.x,l[r+1]=e.y,l[r+2]=e.z}if(3===r){if(!s.faceNormal){const t=p[0],r=p[1],a=p[2];n.subVectors(r,t),o.subVectors(a,r),s.faceNormal=(new e.Vector3).crossVectors(n,o).normalize()}let t=s.normals;4===t.length&&(d[0]=t[0],d[1]=t[1],d[2]=t[2],d[3]=t[0],d[4]=t[2],d[5]=t[3],t=d);for(let e=0,r=t.length;e<r;e++){let r=s.faceNormal;t[e]&&(r=t[e].norm);const a=C+3*e;c[a+0]=r.x,c[a+1]=r.y,c[a+2]=r.z}}if(g!==s.colorCode){null!==g&&u.addGroup(m,f,h.length-1);const t=s.material;null!==t?3===r?h.push(t):2===r&&(a?h.push(t.userData.edgeMaterial.userData.conditionalEdgeMaterial):h.push(t.userData.edgeMaterial)):h.push(s.colorCode),g=s.colorCode,m=C/3,f=p.length}else f+=p.length;C+=3*p.length}f>0&&u.addGroup(m,1/0,h.length-1),u.setAttribute("position",new e.BufferAttribute(l,3)),null!==c&&u.setAttribute("normal",new e.BufferAttribute(c,3));let w=null;if(2===r?w=a?new s(u,1===h.length?h[0]:h):new e.LineSegments(u,1===h.length?h[0]:h):3===r&&(w=new e.Mesh(u,1===h.length?h[0]:h)),a){w.isConditionalLine=!0;const r=new Float32Array(3*t.length*2),a=new Float32Array(3*t.length*2),n=new Float32Array(3*t.length*2);for(let e=0,o=t.length;e<o;e++){const o=t[e],i=o.vertices,s=o.controlPoints,l=s[0],c=s[1],h=i[0],d=i[1],u=3*e*2;r[u+0]=l.x,r[u+1]=l.y,r[u+2]=l.z,r[u+3]=l.x,r[u+4]=l.y,r[u+5]=l.z,a[u+0]=c.x,a[u+1]=c.y,a[u+2]=c.z,a[u+3]=c.x,a[u+4]=c.y,a[u+5]=c.z,n[u+0]=d.x-h.x,n[u+1]=d.y-h.y,n[u+2]=d.z-h.z,n[u+3]=d.x-h.x,n[u+4]=d.y-h.y,n[u+5]=d.z-h.z}u.setAttribute("control0",new e.BufferAttribute(r,3,!1)),u.setAttribute("control1",new e.BufferAttribute(a,3,!1)),u.setAttribute("direction",new e.BufferAttribute(n,3,!1))}return w}class f extends e.Loader{constructor(t){super(t),this.materials=[],this.materialLibrary={},this.partsCache=new g(this),this.fileMap={},this.setMaterials([]),this.smoothNormals=!0,this.partsLibraryPath=""}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const r=new e.FileLoader(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const a=/^0 !COLOUR/,n=(await r.loadAsync(t)).split(/[\n\r]/g),o=[];for(let t=0,e=n.length;t<e;t++){const e=n[t];if(a.test(e)){const t=e.replace(a,""),r=this.parseColorMetaDirective(new h(t));o.push(r)}}this.setMaterials(o)}load(t,a,n,o){const i=new e.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(t=>{this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.applyMaterialsToMesh(t,r,this.materialLibrary,!0),this.computeConstructionSteps(t),a(t)})).catch(o)}),n,o)}parse(t,e){this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.computeConstructionSteps(t),e(t)}))}setMaterials(t){this.materialLibrary={},this.materials=[];for(let e=0,r=t.length;e<r;e++)this.addMaterial(t[e]);return this.addMaterial(this.parseColorMetaDirective(new h("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new h("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(t){return this.fileMap=t,this}addMaterial(t){const e=this.materialLibrary;return e[t.userData.code]||(this.materials.push(t),e[t.userData.code]=t),this}getMaterial(t){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColorMetaDirective(new h("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}return this.materialLibrary[t]||null}applyMaterialsToMesh(t,e,n,o=!1){const i=this,s=e===r;function l(t,l){if(s&&!(l in n)&&!o)return l;const c=t.isLineSegments||t.isConditionalLine;(!c&&l===r||c&&l===a)&&(l=e);let h=null;if(l in n)h=n[l];else{if(!o)return l;if(h=i.getMaterial(l),null===h)throw new Error(`LDrawLoader: Material properties for code ${l} not available.`)}return t.isLineSegments&&(h=h.userData.edgeMaterial,t.isConditionalLine&&(h=h.userData.conditionalEdgeMaterial)),h}t.traverse((t=>{if(t.isMesh||t.isLineSegments)if(Array.isArray(t.material))for(let e=0,r=t.material.length;e<r;e++)t.material[e].isMaterial||(t.material[e]=l(t,t.material[e]));else t.material.isMaterial||(t.material=l(t,t.material))}))}getMainMaterial(){return this.getMaterial(r)}getMainEdgeMaterial(){const t=this.getMainMaterial();return t&&t.userData?t.userData.edgeMaterial:null}parseColorMetaDirective(t){let r=null,a=16711935,n=16711935,o=1,s=!1,l=0,c=0,d=null;const u=t.getToken();if(!u)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".");let g=null;for(;g=t.getToken(),g;)switch(g.toUpperCase()){case"CODE":r=t.getToken();break;case"VALUE":if(a=t.getToken(),a.startsWith("0x"))a="#"+a.substring(2);else if(!a.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+t.getLineNumberString()+".");break;case"EDGE":if(n=t.getToken(),n.startsWith("0x"))n="#"+n.substring(2);else if(!n.startsWith("#")){if(d=this.getMaterial(n),!d)throw new Error("LDrawLoader: Invalid edge color while parsing material"+t.getLineNumberString()+".");d=d.userData.edgeMaterial}break;case"ALPHA":if(o=parseInt(t.getToken()),isNaN(o))throw new Error("LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".");o=Math.max(0,Math.min(1,o/255)),o<1&&(s=!0);break;case"LUMINANCE":if(l=parseInt(t.getToken()),isNaN(l))throw new Error("LDrawLoader: Invalid luminance value in material definition"+h.getLineNumberString()+".");l=Math.max(0,Math.min(1,l/255));break;case"CHROME":c=1;break;case"PEARLESCENT":c=2;break;case"RUBBER":c=3;break;case"MATTE_METALLIC":c=4;break;case"METAL":c=5;break;case"MATERIAL":t.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+g+'" while parsing material'+t.getLineNumberString()+".")}let p=null;switch(c){case 0:p=new e.MeshStandardMaterial({color:a,roughness:.3,metalness:0});break;case 2:p=new e.MeshStandardMaterial({color:a,roughness:.3,metalness:.25});break;case 1:p=new e.MeshStandardMaterial({color:a,roughness:0,metalness:1});break;case 3:p=new e.MeshStandardMaterial({color:a,roughness:.9,metalness:0});break;case 4:p=new e.MeshStandardMaterial({color:a,roughness:.8,metalness:.4});break;case 5:p=new e.MeshStandardMaterial({color:a,roughness:.2,metalness:.85})}return p.transparent=s,p.premultipliedAlpha=!0,p.opacity=o,p.depthWrite=!s,p.color.convertSRGBToLinear(),p.polygonOffset=!0,p.polygonOffsetFactor=1,0!==l&&p.emissive.set(p.color).multiplyScalar(l),d||(d=new e.LineBasicMaterial({color:n,transparent:s,opacity:o,depthWrite:!s}),d.userData.code=r,d.name=u+" - Edge",d.color.convertSRGBToLinear(),d.userData.conditionalEdgeMaterial=new i({fog:!0,transparent:s,depthWrite:!s,color:n,opacity:o}),d.userData.conditionalEdgeMaterial.color.convertSRGBToLinear()),p.userData.code=r,p.name=u,p.userData.edgeMaterial=d,this.addMaterial(p),p}computeConstructionSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingConstructionStep&&e++,t.userData.constructionStep=e)})),t.userData.numConstructionSteps=e+1}}t.LDrawLoader=f,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE)}();
