!function(){var e,t;e=this,t=function(e,t){"use strict";const n=1024;function r(e=1){const r=new Float32Array(4096*e*4),s=new t.DataTexture(r,n,4*e,t.RGBAFormat,t.FloatType);return s.wrapS=t.RepeatWrapping,s.wrapY=t.RepeatWrapping,s.magFilter=t.NearestFilter,s.needsUpdate=!0,s}function s(e,t,r=0){const s=Math.floor(1024);t.arcLengthDivisions=s/2,t.updateArcLengths();const o=t.getSpacedPoints(s),a=t.computeFrenetFrames(s,!0);for(let t=0;t<s;t++){const s=Math.floor(t/n),f=t%n;let c=o[t];i(e,f,c.x,c.y,c.z,0+s+4*r),c=a.tangents[t],i(e,f,c.x,c.y,c.z,1+s+4*r),c=a.normals[t],i(e,f,c.x,c.y,c.z,2+s+4*r),c=a.binormals[t],i(e,f,c.x,c.y,c.z,3+s+4*r)}e.needsUpdate=!0}function i(e,t,n,r,s,i){const o=e.image,{data:a}=o,f=4096*i;a[4*t+f+0]=n,a[4*t+f+1]=r,a[4*t+f+2]=s,a[4*t+f+3]=1}function o(e){return{spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}}}function a(e,t,n=1){e.__ok||(e.__ok=!0,e.onBeforeCompile=e=>{if(e.__modified)return;e.__modified=!0,Object.assign(e.uniforms,t);const r=`\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${4*n}.;\n\t\tfloat textureStacks = 1.;\n\n\t\t${e.vertexShader}\n\t\t`.replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,"\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * 4.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t").replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=r})}class f{constructor(e,n=1){const s=e.clone(),i=r(n),f=o(i);s.traverse((function(e){(e instanceof t.Mesh||e instanceof t.InstancedMesh)&&(e.material=e.material.clone(),a(e.material,f,n))})),this.curveArray=new Array(n),this.curveLengthArray=new Array(n),this.object3D=s,this.splineTexure=i,this.uniforms=f}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");const n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,s(this.splineTexure,t,e)}moveAlongCurve(e){this.uniforms.pathOffset.value+=e}}const c=new t.Matrix4;e.Flow=f,e.InstancedFlow=class extends f{constructor(e,n,r,s){const i=new t.InstancedMesh(r,s,e);i.instanceMatrix.setUsage(t.DynamicDrawUsage),super(i,n),this.offsets=new Array(e).fill(0),this.whichCurve=new Array(e).fill(0)}writeChanges(e){c.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,c),this.object3D.instanceMatrix.needsUpdate=!0}moveIndividualAlongCurve(e,t){this.offsets[e]+=t,this.writeChanges(e)}setCurve(e,t){if(isNaN(t))throw Error("curve index being set is Not a Number (NaN)");this.whichCurve[e]=t,this.writeChanges(e)}},e.getUniforms=o,e.initSplineTexture=r,e.modifyShader=a,e.updateSplineTexture=s,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
