!function(){var e,t;e=this,t=function(e,t,r){"use strict";function o(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var n=o(r);const i=new t.Vector3,l=new t.Vector3,s=new t.Vector3;e.EdgeSplitModifier=class{modify(e,r,o=!0){function u(e,t,r){i.set(y[3*r],y[3*r+1],y[3*r+2]).normalize();const o={splitGroup:[],currentGroup:[r]};for(const n of e)n!==r&&(l.set(y[3*n],y[3*n+1],y[3*n+2]).normalize(),l.dot(i)<t?o.splitGroup.push(n):o.currentGroup.push(n));return o}function f(e,t,r=null){if(0===e.length)return;const o=[];for(const r of e)o.push(u(e,t,r));let n=o[0];for(const e of o)e.currentGroup.length>n.currentGroup.length&&(n=e);null!=r&&h.push({original:r,indexes:n.currentGroup}),n.splitGroup.length&&f(n.splitGroup,t,r||n.currentGroup[0])}if(!0===e.isGeometry)return void console.error("THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use BufferGeometry instead.");let c=!1,a=null;e.attributes.normal&&(c=!0,e=e.clone(),!0===o&&null!==e.index&&(a=e.attributes.normal.array),e.deleteAttribute("normal")),null==e.index&&(e=n.mergeVertices(e));const p=e.index.array,d=e.getAttribute("position").array;let y,g;!function(){y=new Float32Array(3*p.length);for(let e=0;e<p.length;e+=3){let t=p[e];i.set(d[3*t],d[3*t+1],d[3*t+2]),t=p[e+1],l.set(d[3*t],d[3*t+1],d[3*t+2]),t=p[e+2],s.set(d[3*t],d[3*t+1],d[3*t+2]),s.sub(l),i.sub(l);const r=s.cross(i).normalize();for(let t=0;t<3;t++)y[3*(e+t)]=r.x,y[3*(e+t)+1]=r.y,y[3*(e+t)+2]=r.z}}(),function(){g=Array(d.length/3);for(let e=0;e<p.length;e++){const t=p[e];null==g[t]&&(g[t]=[]),g[t].push(e)}}();const h=[];for(const e of g)f(e,Math.cos(r)-.001);const m={};for(const r of Object.keys(e.attributes)){const o=e.attributes[r],n=new o.array.constructor((p.length+h.length)*o.itemSize);n.set(o.array),m[r]=new t.BufferAttribute(n,o.itemSize,o.normalized)}const b=new Uint32Array(p.length);b.set(p);for(let e=0;e<h.length;e++){const t=h[e],r=p[t.original];for(const t of Object.values(m))for(let o=0;o<t.itemSize;o++)t.array[(p.length+e)*t.itemSize+o]=t.array[r*t.itemSize+o];for(const r of t.indexes)b[r]=p.length+e}(e=new t.BufferGeometry).setIndex(new t.BufferAttribute(b,1));for(const t of Object.keys(m))e.setAttribute(t,m[t]);if(c&&(e.computeVertexNormals(),null!==a)){const t=new Array(a.length/3).fill(!1);for(const e of h)t[e.original]=!0;for(let r=0;r<t.length;r++)if(!1===t[r])for(let t=0;t<3;t++)e.attributes.normal.array[3*r+t]=a[3*r+t]}return e}},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("../utils/BufferGeometryUtils.js")):"function"==typeof define&&define.amd?define(["exports","three","../utils/BufferGeometryUtils"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE)}();
