!function(){var e,r;e=this,r=function(e,r){"use strict";e.TessellateModifier=class{constructor(e=.1,r=6){this.maxEdgeLength=e,this.maxIterations=r}modify(e){if(!0===e.isGeometry)return console.error("THREE.TessellateModifier no longer supports Geometry. Use BufferGeometry instead."),e;null!==e.index&&(e=e.toNonIndexed());const t=this.maxIterations,o=this.maxEdgeLength*this.maxEdgeLength,n=new r.Vector3,s=new r.Vector3,u=new r.Vector3,l=new r.Vector3,i=[n,s,u,l],a=new r.Vector3,f=new r.Vector3,c=new r.Vector3,y=new r.Vector3,p=[a,f,c,y],d=new r.Color,m=new r.Color,h=new r.Color,V=new r.Color,w=[d,m,h,V],x=new r.Vector2,A=new r.Vector2,b=new r.Vector2,v=new r.Vector2,T=[x,A,b,v],E=new r.Vector2,g=new r.Vector2,z=new r.Vector2,B=new r.Vector2,C=[E,g,z,B],F=e.attributes,q=void 0!==F.normal,G=void 0!==F.color,H=void 0!==F.uv,R=void 0!==F.uv2;let S=F.position.array,I=q?F.normal.array:null,L=G?F.color.array:null,M=H?F.uv.array:null,j=R?F.uv2.array:null,_=S,D=I,N=L,O=M,P=j,U=0,k=!0;function J(e,r,t){const o=i[e],n=i[r],s=i[t];if(_.push(o.x,o.y,o.z),_.push(n.x,n.y,n.z),_.push(s.x,s.y,s.z),q){const o=p[e],n=p[r],s=p[t];D.push(o.x,o.y,o.z),D.push(n.x,n.y,n.z),D.push(s.x,s.y,s.z)}if(G){const o=w[e],n=w[r],s=w[t];N.push(o.x,o.y,o.z),N.push(n.x,n.y,n.z),N.push(s.x,s.y,s.z)}if(H){const o=T[e],n=T[r],s=T[t];O.push(o.x,o.y),O.push(n.x,n.y),O.push(s.x,s.y)}if(R){const o=C[e],n=C[r],s=C[t];P.push(o.x,o.y),P.push(n.x,n.y),P.push(s.x,s.y)}}for(;k&&U<t;){U++,k=!1,S=_,_=[],q&&(I=D,D=[]),G&&(L=N,N=[]),H&&(M=O,O=[]),R&&(j=P,P=[]);for(let e=0,r=0,t=S.length;e<t;e+=9,r+=6){n.fromArray(S,e+0),s.fromArray(S,e+3),u.fromArray(S,e+6),q&&(a.fromArray(I,e+0),f.fromArray(I,e+3),c.fromArray(I,e+6)),G&&(d.fromArray(L,e+0),m.fromArray(L,e+3),h.fromArray(L,e+6)),H&&(x.fromArray(M,r+0),A.fromArray(M,r+2),b.fromArray(M,r+4)),R&&(E.fromArray(j,r+0),g.fromArray(j,r+2),z.fromArray(j,r+4));const t=n.distanceToSquared(s),i=s.distanceToSquared(u),p=n.distanceToSquared(u);t>o||i>o||p>o?(k=!0,t>=i&&t>=p?(l.lerpVectors(n,s,.5),q&&y.lerpVectors(a,f,.5),G&&V.lerpColors(d,m,.5),H&&v.lerpVectors(x,A,.5),R&&B.lerpVectors(E,g,.5),J(0,3,2),J(3,1,2)):i>=t&&i>=p?(l.lerpVectors(s,u,.5),q&&y.lerpVectors(f,c,.5),G&&V.lerpColors(m,h,.5),H&&v.lerpVectors(A,b,.5),R&&B.lerpVectors(g,z,.5),J(0,1,3),J(3,2,0)):(l.lerpVectors(n,u,.5),q&&y.lerpVectors(a,c,.5),G&&V.lerpColors(d,h,.5),H&&v.lerpVectors(x,b,.5),R&&B.lerpVectors(E,z,.5),J(0,1,3),J(3,1,2))):J(0,1,2)}}const K=new r.BufferGeometry;return K.setAttribute("position",new r.Float32BufferAttribute(_,3)),q&&K.setAttribute("normal",new r.Float32BufferAttribute(D,3)),G&&K.setAttribute("color",new r.Float32BufferAttribute(N,3)),H&&K.setAttribute("uv",new r.Float32BufferAttribute(O,2)),R&&K.setAttribute("uv2",new r.Float32BufferAttribute(P,2)),K}},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
