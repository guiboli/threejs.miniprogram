!function(){var e,t;e=this,t=function(e,t,o){"use strict";function s(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(o){if("default"!==o){var s=Object.getOwnPropertyDescriptor(e,o);Object.defineProperty(t,o,s.get?s:{enumerable:!0,get:function(){return e[o]}})}})),t.default=e,Object.freeze(t)}var i=s(o);const r=new t.Vector3,n=new t.Vector3;function h(e,t){const o=e.indexOf(t);o>-1&&e.splice(o,1)}function l(e,t){const o=t.position.distanceTo(e.position);let s=0;const i=[];for(let o=0,s=e.faces.length;o<s;o++){const s=e.faces[o];s.hasVertex(t)&&i.push(s)}for(let t=0,o=e.faces.length;t<o;t++){let o=1;const r=e.faces[t];for(let e=0;e<i.length;e++){const t=i[e],s=r.normal.dot(t.normal);o=Math.min(o,(1.001-s)/2)}s=Math.max(s,o)}return i.length<2&&(s=1),o*s+0}function c(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const o=l(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=o,e.minCost=o,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=o,o<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=o)}e.collapseCost=e.totalCost/e.costCount}function f(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;)h(e.neighbors.pop().neighbors,e);h(t,e)}function u(e,t){h(t,e),e.v1&&h(e.v1.faces,e),e.v2&&h(e.v2.faces,e),e.v3&&h(e.v3.faces,e);const o=[e.v1,e.v2,e.v3];for(let e=0;e<3;e++){const t=o[e],s=o[(e+1)%3];t&&s&&(t.removeIfNonNeighbor(s),s.removeIfNonNeighbor(t))}}function a(e,t,o,s){if(!s)return void f(o,e);const i=[];for(let e=0;e<o.neighbors.length;e++)i.push(o.neighbors[e]);for(let e=o.faces.length-1;e>=0;e--)o.faces[e].hasVertex(s)&&u(o.faces[e],t);for(let e=o.faces.length-1;e>=0;e--)o.faces[e].replaceVertex(o,s);f(o,e);for(let e=0;e<i.length;e++)c(i[e])}function g(e){let t=e[0];for(let o=0;o<e.length;o++)e[o].collapseCost<t.collapseCost&&(t=e[o]);return t}class v{constructor(e,o,s,i,r,n){this.a=i,this.b=r,this.c=n,this.v1=e,this.v2=o,this.v3=s,this.normal=new t.Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(o),e.addUniqueNeighbor(s),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(s),s.faces.push(this),s.addUniqueNeighbor(e),s.addUniqueNeighbor(o)}computeNormal(){const e=this.v1.position,t=this.v2.position,o=this.v3.position;r.subVectors(o,t),n.subVectors(e,t),r.cross(n).normalize(),this.normal.copy(r)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),h(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class b{constructor(e){this.position=e,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){var t,o;t=this.neighbors,o=e,-1===t.indexOf(o)&&t.push(o)}removeIfNonNeighbor(e){const t=this.neighbors,o=this.faces,s=t.indexOf(e);if(-1!==s){for(let t=0;t<o.length;t++)if(o[t].hasVertex(e))return;t.splice(s,1)}}}e.SimplifyModifier=class{modify(e,o){if(!0===e.isGeometry)return void console.error("THREE.SimplifyModifier no longer supports Geometry. Use BufferGeometry instead.");const s=(e=e.clone()).attributes;for(const t in s)"position"!==t&&e.deleteAttribute(t);const r=[],n=[],h=(e=i.mergeVertices(e)).getAttribute("position");for(let e=0;e<h.count;e++){const o=(new t.Vector3).fromBufferAttribute(h,e),s=new b(o);r.push(s)}let l,f=e.getIndex();if(null!==f)for(let e=0;e<f.count;e+=3){const t=f.getX(e),o=f.getX(e+1),s=f.getX(e+2),i=new v(r[t],r[o],r[s],t,o,s);n.push(i)}else for(let e=0;e<h.count;e+=3){const t=e,o=e+1,s=e+2,i=new v(r[t],r[o],r[s],t,o,s);n.push(i)}for(let e=0,t=r.length;e<t;e++)c(r[e]);let u=o;for(;u--;){if(l=g(r),!l){console.log("THREE.SimplifyModifier: No next vertex");break}a(r,n,l,l.collapseNeighbor)}const d=new t.BufferGeometry,p=[];f=[];for(let e=0;e<r.length;e++){const t=r[e].position;p.push(t.x,t.y,t.z),r[e].id=e}for(let e=0;e<n.length;e++){const t=n[e];f.push(t.v1.id,t.v2.id,t.v3.id)}return d.setAttribute("position",new t.Float32BufferAttribute(p,3)),d.setIndex(f),d}},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("../utils/BufferGeometryUtils.js")):"function"==typeof define&&define.amd?define(["exports","three","../utils/BufferGeometryUtils"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE)}();
