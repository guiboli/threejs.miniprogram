!function(){var t,e;t=this,e=function(t,e,n){"use strict";function o(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,o.get?o:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var s=o(n);t.NURBSSurface=class{constructor(t,n,o,s,i){this.degree1=t,this.degree2=n,this.knots1=o,this.knots2=s,this.controlPoints=[];const r=o.length-t-1,c=s.length-n-1;for(let t=0;t<r;++t){this.controlPoints[t]=[];for(let n=0;n<c;++n){const o=i[t][n];this.controlPoints[t][n]=new e.Vector4(o.x,o.y,o.z,o.w)}}}getPoint(t,e,n){const o=this.knots1[0]+t*(this.knots1[this.knots1.length-1]-this.knots1[0]),i=this.knots2[0]+e*(this.knots2[this.knots2.length-1]-this.knots2[0]);s.calcSurfacePoint(this.degree1,this.degree2,this.knots1,this.knots2,this.controlPoints,o,i,n)}},Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("./NURBSUtils.js")):"function"==typeof define&&define.amd?define(["exports","three","./NURBSUtils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE,t.THREE)}();
