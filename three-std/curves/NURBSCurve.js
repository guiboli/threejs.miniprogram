!function(){var t,e;t=this,e=function(t,e,n){"use strict";function s(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var o=s(n);class i extends e.Curve{constructor(t,n,s,o,i){super(),this.degree=t,this.knots=n,this.controlPoints=[],this.startKnot=o||0,this.endKnot=i||this.knots.length-1;for(let t=0;t<s.length;++t){const n=s[t];this.controlPoints[t]=new e.Vector4(n.x,n.y,n.z,n.w)}}getPoint(t,n=new e.Vector3){const s=n,i=this.knots[this.startKnot]+t*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=o.calcBSplinePoint(this.degree,this.knots,this.controlPoints,i);return 1!==r.w&&r.divideScalar(r.w),s.set(r.x,r.y,r.z)}getTangent(t,n=new e.Vector3){const s=n,i=this.knots[0]+t*(this.knots[this.knots.length-1]-this.knots[0]),r=o.calcNURBSDerivatives(this.degree,this.knots,this.controlPoints,i,1);return s.copy(r[1]).normalize(),s}}t.NURBSCurve=i,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("./NURBSUtils.js")):"function"==typeof define&&define.amd?define(["exports","three","./NURBSUtils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE,t.THREE)}();
