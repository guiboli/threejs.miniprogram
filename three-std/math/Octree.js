!function(){var e,t;e=this,t=function(e,t,n){"use strict";const s=new t.Vector3,r=new t.Vector3,i=new t.Plane,o=new t.Line3,a=new t.Line3,l=new t.Sphere,h=new n.Capsule;class c{constructor(e){this.triangles=[],this.box=e,this.subTrees=[]}addTriangle(e){return this.bounds||(this.bounds=new t.Box3),this.bounds.min.x=Math.min(this.bounds.min.x,e.a.x,e.b.x,e.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,e.a.y,e.b.y,e.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,e.a.z,e.b.z,e.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,e.a.x,e.b.x,e.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,e.a.y,e.b.y,e.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,e.a.z,e.b.z,e.c.z),this.triangles.push(e),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(e){if(!this.box)return;const n=[],i=r.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let e=0;e<2;e++)for(let r=0;r<2;r++)for(let o=0;o<2;o++){const a=new t.Box3,l=s.set(e,r,o);a.min.copy(this.box.min).add(l.multiply(i)),a.max.copy(a.min).add(i),n.push(new c(a))}let o;for(;o=this.triangles.pop();)for(let e=0;e<n.length;e++)n[e].box.intersectsTriangle(o)&&n[e].triangles.push(o);for(let t=0;t<n.length;t++){const s=n[t].triangles.length;s>8&&e<16&&n[t].split(e+1),0!==s&&this.subTrees.push(n[t])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getRayTriangles(e,t)}return t}triangleCapsuleIntersect(e,t){t.getPlane(i);const n=i.distanceToPoint(e.start)-e.radius,r=i.distanceToPoint(e.end)-e.radius;if(n>0&&r>0||n<-e.radius&&r<-e.radius)return!1;const l=Math.abs(n/(Math.abs(n)+Math.abs(r))),h=s.copy(e.start).lerp(e.end,l);if(t.containsPoint(h))return{normal:i.normal.clone(),point:h.clone(),depth:Math.abs(Math.min(n,r))};const c=e.radius*e.radius,u=o.set(e.start,e.end),d=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<d.length;t++){const n=a.set(d[t][0],d[t][1]),[s,r]=e.lineLineMinimumPoints(u,n);if(s.distanceToSquared(r)<c)return{normal:s.clone().sub(r).normalize(),point:r.clone(),depth:e.radius-s.distanceTo(r)}}return!1}triangleSphereIntersect(e,t){if(t.getPlane(i),!e.intersectsPlane(i))return!1;const n=Math.abs(i.distanceToSphere(e)),a=e.radius*e.radius-n*n,l=i.projectPoint(e.center,s);if(t.containsPoint(e.center))return{normal:i.normal.clone(),point:l.clone(),depth:Math.abs(i.distanceToSphere(e))};const h=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<h.length;t++){o.set(h[t][0],h[t][1]),o.closestPointToPoint(l,!0,r);const n=r.distanceToSquared(e.center);if(n<a)return{normal:e.center.clone().sub(r).normalize(),point:r.clone(),depth:e.radius-Math.sqrt(n)}}return!1}getSphereTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getSphereTriangles(e,t)}}getCapsuleTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getCapsuleTriangles(e,t)}}sphereIntersect(e){l.copy(e);const t=[];let n,s=!1;this.getSphereTriangles(e,t);for(let e=0;e<t.length;e++)(n=this.triangleSphereIntersect(l,t[e]))&&(s=!0,l.center.add(n.normal.multiplyScalar(n.depth)));if(s){const t=l.center.clone().sub(e.center),n=t.length();return{normal:t.normalize(),depth:n}}return!1}capsuleIntersect(e){h.copy(e);const n=[];let r,i=!1;this.getCapsuleTriangles(h,n);for(let e=0;e<n.length;e++)(r=this.triangleCapsuleIntersect(h,n[e]))&&(i=!0,h.translate(r.normal.multiplyScalar(r.depth)));if(i){const n=h.getCenter(new t.Vector3).sub(e.getCenter(s)),r=n.length();return{normal:n.normalize(),depth:r}}return!1}rayIntersect(e){if(0===e.direction.length())return;const t=[];let n,r,i=1e100;this.getRayTriangles(e,t);for(let o=0;o<t.length;o++){const a=e.intersectTriangle(t[o].a,t[o].b,t[o].c,!0,s);if(a){const s=a.sub(e.origin).length();i>s&&(r=a.clone().add(e.origin),i=s,n=t[o])}}return i<1e100&&{distance:i,triangle:n,position:r}}fromGraphNode(e){return e.updateWorldMatrix(!0,!0),e.traverse((e=>{if(!0===e.isMesh){let n,s=!1;null!==e.geometry.index?(s=!0,n=e.geometry.toNonIndexed()):n=e.geometry;const r=n.getAttribute("position");for(let n=0;n<r.count;n+=3){const s=(new t.Vector3).fromBufferAttribute(r,n),i=(new t.Vector3).fromBufferAttribute(r,n+1),o=(new t.Vector3).fromBufferAttribute(r,n+2);s.applyMatrix4(e.matrixWorld),i.applyMatrix4(e.matrixWorld),o.applyMatrix4(e.matrixWorld),this.addTriangle(new t.Triangle(s,i,o))}s&&n.dispose()}})),this.build(),this}}e.Octree=c,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("./Capsule.js")):"function"==typeof define&&define.amd?define(["exports","three","./Capsule"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE,e.THREE)}();
