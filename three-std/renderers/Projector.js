!function(){var e,t;e=this,t=function(e,t){"use strict";class r{constructor(){this.id=0,this.object=null,this.z=0,this.renderOrder=0}}class o{constructor(){this.id=0,this.v1=new i,this.v2=new i,this.v3=new i,this.normalModel=new t.Vector3,this.vertexNormalsModel=[new t.Vector3,new t.Vector3,new t.Vector3],this.vertexNormalsLength=0,this.color=new t.Color,this.material=null,this.uvs=[new t.Vector2,new t.Vector2,new t.Vector2],this.z=0,this.renderOrder=0}}class i{constructor(){this.position=new t.Vector3,this.positionWorld=new t.Vector3,this.positionScreen=new t.Vector4,this.visible=!0}copy(e){this.positionWorld.copy(e.positionWorld),this.positionScreen.copy(e.positionScreen)}}class n{constructor(){this.id=0,this.v1=new i,this.v2=new i,this.vertexColors=[new t.Color,new t.Color],this.material=null,this.z=0,this.renderOrder=0}}class s{constructor(){this.id=0,this.object=null,this.x=0,this.y=0,this.z=0,this.rotation=0,this.scale=new t.Vector2,this.material=null,this.renderOrder=0}}e.Projector=class{constructor(){let e,l,c,a,p,u,h,f,d,m,y,x=0,g=0,v=0,w=0,M=0;const b={objects:[],lights:[],elements:[]},j=new t.Vector3,S=new t.Vector4,z=new t.Box3(new t.Vector3(-1,-1,-1),new t.Vector3(1,1,1)),V=new t.Box3,E=new Array(3),T=new t.Matrix4,O=new t.Matrix4,R=new t.Matrix4,C=new t.Frustum,P=[],G=[],H=[],W=[],B=[];this.projectVector=function(e,t){console.warn("THREE.Projector: .projectVector() is now vector.project()."),e.project(t)},this.unprojectVector=function(e,t){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),e.unproject(t)},this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")};const L=new function(){const e=[],r=[],o=[];let s=null;const l=new t.Matrix3;function u(e){const t=e.position,r=e.positionWorld,o=e.positionScreen;r.copy(t).applyMatrix4(y),o.copy(r).applyMatrix4(O);const i=1/o.w;o.x*=i,o.y*=i,o.z*=i,e.visible=o.x>=-1&&o.x<=1&&o.y>=-1&&o.y<=1&&o.z>=-1&&o.z<=1}function d(e,t,r){return!0===e.visible||!0===t.visible||!0===r.visible||(E[0]=e.positionScreen,E[1]=t.positionScreen,E[2]=r.positionScreen,z.intersectsBox(V.setFromPoints(E)))}function m(e,t,r){return(r.positionScreen.x-e.positionScreen.x)*(t.positionScreen.y-e.positionScreen.y)-(r.positionScreen.y-e.positionScreen.y)*(t.positionScreen.x-e.positionScreen.x)<0}return{setObject:function(t){s=t,l.getNormalMatrix(s.matrixWorld),e.length=0,r.length=0,o.length=0},projectVertex:u,checkTriangleVisibility:d,checkBackfaceCulling:m,pushVertex:function(e,t,r){c=function(){if(a===g){const e=new i;return G.push(e),g++,a++,e}return G[a++]}(),c.position.set(e,t,r),u(c)},pushNormal:function(t,r,o){e.push(t,r,o)},pushColor:function(e,t,o){r.push(e,t,o)},pushUv:function(e,t){o.push(e,t)},pushLine:function(e,t){const o=G[e],i=G[t];o.positionScreen.copy(o.position).applyMatrix4(R),i.positionScreen.copy(i.position).applyMatrix4(R),!0===function(e,t){let r=0,o=1;const i=e.z+e.w,n=t.z+t.w,s=-e.z+e.w,l=-t.z+t.w;return i>=0&&n>=0&&s>=0&&l>=0||!(i<0&&n<0||s<0&&l<0)&&(i<0?r=Math.max(r,i/(i-n)):n<0&&(o=Math.min(o,i/(i-n))),s<0?r=Math.max(r,s/(s-l)):l<0&&(o=Math.min(o,s/(s-l))),!(o<r||(e.lerp(t,r),t.lerp(e,1-o),0)))}(o.positionScreen,i.positionScreen)&&(o.positionScreen.multiplyScalar(1/o.positionScreen.w),i.positionScreen.multiplyScalar(1/i.positionScreen.w),h=function(){if(f===w){const e=new n;return W.push(e),w++,f++,e}return W[f++]}(),h.id=s.id,h.v1.copy(o),h.v2.copy(i),h.z=Math.max(o.positionScreen.z,i.positionScreen.z),h.renderOrder=s.renderOrder,h.material=s.material,s.material.vertexColors&&(h.vertexColors[0].fromArray(r,3*e),h.vertexColors[1].fromArray(r,3*t)),b.elements.push(h))},pushTriangle:function(i,n,c,a){const u=G[i],h=G[n],f=G[c];if(!1!==d(u,h,f)&&(a.side===t.DoubleSide||!0===m(u,h,f))){p=U(),p.id=s.id,p.v1.copy(u),p.v2.copy(h),p.v3.copy(f),p.z=(u.positionScreen.z+h.positionScreen.z+f.positionScreen.z)/3,p.renderOrder=s.renderOrder,j.subVectors(f.position,h.position),S.subVectors(u.position,h.position),j.cross(S),p.normalModel.copy(j),p.normalModel.applyMatrix3(l).normalize();for(let t=0;t<3;t++){const r=p.vertexNormalsModel[t];r.fromArray(e,3*arguments[t]),r.applyMatrix3(l).normalize(),p.uvs[t].fromArray(o,2*arguments[t])}p.vertexNormalsLength=3,p.material=a,a.vertexColors&&p.color.fromArray(r,3*i),b.elements.push(p)}}}};function A(e){if(!1===e.visible)return;if(e.isLight)b.lights.push(e);else if(e.isMesh||e.isLine||e.isPoints){if(!1===e.material.visible)return;if(!0===e.frustumCulled&&!1===C.intersectsObject(e))return;N(e)}else if(e.isSprite){if(!1===e.material.visible)return;if(!0===e.frustumCulled&&!1===C.intersectsSprite(e))return;N(e)}const t=e.children;for(let e=0,r=t.length;e<r;e++)A(t[e])}function N(t){e=function(){if(l===x){const e=new r;return P.push(e),x++,l++,e}return P[l++]}(),e.id=t.id,e.object=t,j.setFromMatrixPosition(t.matrixWorld),j.applyMatrix4(O),e.z=j.z,e.renderOrder=t.renderOrder,b.objects.push(e)}function F(e,t,r){const o=1/e.w;e.z*=o,e.z>=-1&&e.z<=1&&(d=function(){if(m===M){const e=new s;return B.push(e),M++,m++,e}return B[m++]}(),d.id=t.id,d.x=e.x*o,d.y=e.y*o,d.z=e.z,d.renderOrder=t.renderOrder,d.object=t,d.rotation=t.rotation,d.scale.x=t.scale.x*Math.abs(d.x-(e.x+r.projectionMatrix.elements[0])/(e.w+r.projectionMatrix.elements[12])),d.scale.y=t.scale.y*Math.abs(d.y-(e.y+r.projectionMatrix.elements[5])/(e.w+r.projectionMatrix.elements[13])),d.material=t.material,b.elements.push(d))}function U(){if(u===v){const e=new o;return H.push(e),v++,u++,e}return H[u++]}function k(e,t){return e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id!==t.id?e.id-t.id:0}this.projectScene=function(e,t,r,o){u=0,f=0,m=0,b.elements.length=0,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),T.copy(t.matrixWorldInverse),O.multiplyMatrices(t.projectionMatrix,T),C.setFromProjectionMatrix(O),l=0,b.objects.length=0,b.lights.length=0,A(e),!0===r&&b.objects.sort(k);const i=b.objects;for(let e=0,r=i.length;e<r;e++){const r=i[e].object,o=r.geometry;if(L.setObject(r),y=r.matrixWorld,a=0,r.isMesh){if(o.isBufferGeometry){let e=r.material;const t=Array.isArray(e),i=o.attributes,n=o.groups;if(void 0===i.position)continue;const s=i.position.array;for(let e=0,t=s.length;e<t;e+=3){let t=s[e],i=s[e+1],n=s[e+2];const l=o.morphAttributes.position;if(void 0!==l){const c=o.morphTargetsRelative,a=r.morphTargetInfluences;for(let r=0,o=l.length;r<o;r++){const o=a[r];if(0===o)continue;const p=l[r];c?(t+=p.getX(e/3)*o,i+=p.getY(e/3)*o,n+=p.getZ(e/3)*o):(t+=(p.getX(e/3)-s[e])*o,i+=(p.getY(e/3)-s[e+1])*o,n+=(p.getZ(e/3)-s[e+2])*o)}}L.pushVertex(t,i,n)}if(void 0!==i.normal){const e=i.normal.array;for(let t=0,r=e.length;t<r;t+=3)L.pushNormal(e[t],e[t+1],e[t+2])}if(void 0!==i.color){const e=i.color.array;for(let t=0,r=e.length;t<r;t+=3)L.pushColor(e[t],e[t+1],e[t+2])}if(void 0!==i.uv){const e=i.uv.array;for(let t=0,r=e.length;t<r;t+=2)L.pushUv(e[t],e[t+1])}if(null!==o.index){const i=o.index.array;if(n.length>0)for(let o=0;o<n.length;o++){const s=n[o];if(e=!0===t?r.material[s.materialIndex]:r.material,void 0!==e)for(let t=s.start,r=s.start+s.count;t<r;t+=3)L.pushTriangle(i[t],i[t+1],i[t+2],e)}else for(let t=0,r=i.length;t<r;t+=3)L.pushTriangle(i[t],i[t+1],i[t+2],e)}else if(n.length>0)for(let o=0;o<n.length;o++){const i=n[o];if(e=!0===t?r.material[i.materialIndex]:r.material,void 0!==e)for(let t=i.start,r=i.start+i.count;t<r;t+=3)L.pushTriangle(t,t+1,t+2,e)}else for(let t=0,r=s.length/3;t<r;t+=3)L.pushTriangle(t,t+1,t+2,e)}else if(o.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.")}else if(r.isLine){if(R.multiplyMatrices(O,y),o.isBufferGeometry){const e=o.attributes;if(void 0!==e.position){const t=e.position.array;for(let e=0,r=t.length;e<r;e+=3)L.pushVertex(t[e],t[e+1],t[e+2]);if(void 0!==e.color){const t=e.color.array;for(let e=0,r=t.length;e<r;e+=3)L.pushColor(t[e],t[e+1],t[e+2])}if(null!==o.index){const e=o.index.array;for(let t=0,r=e.length;t<r;t+=2)L.pushLine(e[t],e[t+1])}else{const e=r.isLineSegments?2:1;for(let r=0,o=t.length/3-1;r<o;r+=e)L.pushLine(r,r+1)}}}else if(o.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.")}else if(r.isPoints){if(R.multiplyMatrices(O,y),o.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");if(o.isBufferGeometry){const e=o.attributes;if(void 0!==e.position){const o=e.position.array;for(let e=0,i=o.length;e<i;e+=3)S.set(o[e],o[e+1],o[e+2],1),S.applyMatrix4(R),F(S,r,t)}}}else r.isSprite&&(r.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,r.matrixWorld),S.set(y.elements[12],y.elements[13],y.elements[14],1),S.applyMatrix4(O),F(S,r,t))}return!0===o&&b.elements.sort(k),b}}},e.RenderableFace=o,e.RenderableLine=n,e.RenderableObject=r,e.RenderableSprite=s,e.RenderableVertex=i,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
