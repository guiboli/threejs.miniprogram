!function(){var t,o;t=this,o=function(t,o){"use strict";class e extends o.BufferGeometry{constructor(t,e,s,i){super();const r=[],u=[],p=[],l=new o.Vector3,c=new o.Matrix4;c.makeRotationFromEuler(s),c.setPosition(e);const a=new o.Matrix4;function f(o,e,s){e.applyMatrix4(t.matrixWorld),e.applyMatrix4(a),s.transformDirection(t.matrixWorld),o.push(new n(e.clone(),s.clone()))}function h(t,o){const e=[],n=.5*Math.abs(i.dot(o));for(let s=0;s<t.length;s+=3){let i,r,u,p,l=0;const c=t[s+0].position.dot(o)-n>0,a=t[s+1].position.dot(o)-n>0,f=t[s+2].position.dot(o)-n>0;switch(l=(c?1:0)+(a?1:0)+(f?1:0),l){case 0:e.push(t[s]),e.push(t[s+1]),e.push(t[s+2]);break;case 1:if(c&&(i=t[s+1],r=t[s+2],u=m(t[s],i,o,n),p=m(t[s],r,o,n)),a){i=t[s],r=t[s+2],u=m(t[s+1],i,o,n),p=m(t[s+1],r,o,n),e.push(u),e.push(r.clone()),e.push(i.clone()),e.push(r.clone()),e.push(u.clone()),e.push(p);break}f&&(i=t[s],r=t[s+1],u=m(t[s+2],i,o,n),p=m(t[s+2],r,o,n)),e.push(i.clone()),e.push(r.clone()),e.push(u),e.push(p),e.push(u.clone()),e.push(r.clone());break;case 2:c||(i=t[s].clone(),r=m(i,t[s+1],o,n),u=m(i,t[s+2],o,n),e.push(i),e.push(r),e.push(u)),a||(i=t[s+1].clone(),r=m(i,t[s+2],o,n),u=m(i,t[s],o,n),e.push(i),e.push(r),e.push(u)),f||(i=t[s+2].clone(),r=m(i,t[s],o,n),u=m(i,t[s+1],o,n),e.push(i),e.push(r),e.push(u))}}return e}function m(t,e,s,i){const r=t.position.dot(s)-i,u=r/(r-(e.position.dot(s)-i));return new n(new o.Vector3(t.position.x+u*(e.position.x-t.position.x),t.position.y+u*(e.position.y-t.position.y),t.position.z+u*(e.position.z-t.position.z)),new o.Vector3(t.normal.x+u*(e.normal.x-t.normal.x),t.normal.y+u*(e.normal.y-t.normal.y),t.normal.z+u*(e.normal.z-t.normal.z)))}a.copy(c).invert(),function(){let e=[];const n=new o.Vector3,s=new o.Vector3;if(!0===t.geometry.isGeometry)return void console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");const a=t.geometry,m=a.attributes.position,y=a.attributes.normal;if(null!==a.index){const t=a.index;for(let o=0;o<t.count;o++)n.fromBufferAttribute(m,t.getX(o)),s.fromBufferAttribute(y,t.getX(o)),f(e,n,s)}else for(let t=0;t<m.count;t++)n.fromBufferAttribute(m,t),s.fromBufferAttribute(y,t),f(e,n,s);e=h(e,l.set(1,0,0)),e=h(e,l.set(-1,0,0)),e=h(e,l.set(0,1,0)),e=h(e,l.set(0,-1,0)),e=h(e,l.set(0,0,1)),e=h(e,l.set(0,0,-1));for(let t=0;t<e.length;t++){const o=e[t];p.push(.5+o.position.x/i.x,.5+o.position.y/i.y),o.position.applyMatrix4(c),r.push(o.position.x,o.position.y,o.position.z),u.push(o.normal.x,o.normal.y,o.normal.z)}}(),this.setAttribute("position",new o.Float32BufferAttribute(r,3)),this.setAttribute("normal",new o.Float32BufferAttribute(u,3)),this.setAttribute("uv",new o.Float32BufferAttribute(p,2))}}class n{constructor(t,o){this.position=t,this.normal=o}clone(){return new this.constructor(this.position.clone(),this.normal.clone())}}t.DecalGeometry=e,t.DecalVertex=n,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?o(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],o):o((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t["THREE-STD"]||{},t.THREE)}();
