!function(){var e,t;e=this,t=function(e,t){"use strict";const s=new t.Matrix4,o=new t.Object3D,r=new t.Vector3;class n extends t.EventDispatcher{constructor(){super(),this.uuid=t.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(e){const s=(new t.Matrix3).getNormalMatrix(e);for(let t=0,s=this.vertices.length;t<s;t++)this.vertices[t].applyMatrix4(e);for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal.applyMatrix3(s).normalize();for(let e=0,o=t.vertexNormals.length;e<o;e++)t.vertexNormals[e].applyMatrix3(s).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(e){return s.makeRotationX(e),this.applyMatrix4(s),this}rotateY(e){return s.makeRotationY(e),this.applyMatrix4(s),this}rotateZ(e){return s.makeRotationZ(e),this.applyMatrix4(s),this}translate(e,t,o){return s.makeTranslation(e,t,o),this.applyMatrix4(s),this}scale(e,t,o){return s.makeScale(e,t,o),this.applyMatrix4(s),this}lookAt(e){return o.lookAt(e),o.updateMatrix(),this.applyMatrix4(o.matrix),this}fromBufferGeometry(e){const s=this,o=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const n=r.position,i=r.normal,a=r.color,c=r.uv,h=r.uv2;void 0!==h&&(this.faceVertexUvs[1]=[]);for(let e=0;e<n.count;e++)s.vertices.push((new t.Vector3).fromBufferAttribute(n,e)),void 0!==a&&s.colors.push((new t.Color).fromBufferAttribute(a,e));function u(e,o,r,n){const u=void 0===a?[]:[s.colors[e].clone(),s.colors[o].clone(),s.colors[r].clone()],p=void 0===i?[]:[(new t.Vector3).fromBufferAttribute(i,e),(new t.Vector3).fromBufferAttribute(i,o),(new t.Vector3).fromBufferAttribute(i,r)],m=new l(e,o,r,p,u,n);s.faces.push(m),void 0!==c&&s.faceVertexUvs[0].push([(new t.Vector2).fromBufferAttribute(c,e),(new t.Vector2).fromBufferAttribute(c,o),(new t.Vector2).fromBufferAttribute(c,r)]),void 0!==h&&s.faceVertexUvs[1].push([(new t.Vector2).fromBufferAttribute(h,e),(new t.Vector2).fromBufferAttribute(h,o),(new t.Vector2).fromBufferAttribute(h,r)])}const p=e.groups;if(p.length>0)for(let e=0;e<p.length;e++){const t=p[e],s=t.start;for(let e=s,r=s+t.count;e<r;e+=3)void 0!==o?u(o.getX(e),o.getX(e+1),o.getX(e+2),t.materialIndex):u(e,e+1,e+2,t.materialIndex)}else if(void 0!==o)for(let e=0;e<o.count;e+=3)u(o.getX(e),o.getX(e+1),o.getX(e+2));else for(let e=0;e<n.count;e+=3)u(e,e+1,e+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(r).negate(),this.translate(r.x,r.y,r.z),this}normalize(){this.computeBoundingSphere();const e=this.boundingSphere.center,s=this.boundingSphere.radius,o=0===s?1:1/s,r=new t.Matrix4;return r.set(o,0,0,-o*e.x,0,o,0,-o*e.y,0,0,o,-o*e.z,0,0,0,1),this.applyMatrix4(r),this}computeFaceNormals(){const e=new t.Vector3,s=new t.Vector3;for(let t=0,o=this.faces.length;t<o;t++){const o=this.faces[t],r=this.vertices[o.a],n=this.vertices[o.b],i=this.vertices[o.c];e.subVectors(i,n),s.subVectors(r,n),e.cross(s),e.normalize(),o.normal.copy(e)}}computeVertexNormals(e=!0){const s=new Array(this.vertices.length);for(let e=0,o=this.vertices.length;e<o;e++)s[e]=new t.Vector3;if(e){const e=new t.Vector3,o=new t.Vector3;for(let t=0,r=this.faces.length;t<r;t++){const r=this.faces[t],n=this.vertices[r.a],i=this.vertices[r.b],l=this.vertices[r.c];e.subVectors(l,i),o.subVectors(n,i),e.cross(o),s[r.a].add(e),s[r.b].add(e),s[r.c].add(e)}}else{this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];s[t.a].add(t.normal),s[t.b].add(t.normal),s[t.c].add(t.normal)}}for(let e=0,t=this.vertices.length;e<t;e++)s[e].normalize();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=t.vertexNormals;3===o.length?(o[0].copy(s[t.a]),o[1].copy(s[t.b]),o[2].copy(s[t.c])):(o[0]=s[t.a].clone(),o[1]=s[t.b].clone(),o[2]=s[t.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.__originalFaceNormal?t.__originalFaceNormal.copy(t.normal):t.__originalFaceNormal=t.normal.clone(),t.__originalVertexNormals||(t.__originalVertexNormals=[]);for(let e=0,s=t.vertexNormals.length;e<s;e++)t.__originalVertexNormals[e]?t.__originalVertexNormals[e].copy(t.vertexNormals[e]):t.__originalVertexNormals[e]=t.vertexNormals[e].clone()}const e=new n;e.faces=this.faces;for(let s=0,o=this.morphTargets.length;s<o;s++){if(!this.morphNormals[s]){this.morphNormals[s]={},this.morphNormals[s].faceNormals=[],this.morphNormals[s].vertexNormals=[];const e=this.morphNormals[s].faceNormals,o=this.morphNormals[s].vertexNormals;for(let s=0,r=this.faces.length;s<r;s++){const s=new t.Vector3,r={a:new t.Vector3,b:new t.Vector3,c:new t.Vector3};e.push(s),o.push(r)}}const o=this.morphNormals[s];e.vertices=this.morphTargets[s].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=o.faceNormals[e],r=o.vertexNormals[e];s.copy(t.normal),r.a.copy(t.vertexNormals[0]),r.b.copy(t.vertexNormals[1]),r.c.copy(t.vertexNormals[2])}}for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal=t.__originalFaceNormal,t.vertexNormals=t.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new t.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new t.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(e,s,o=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const n=this.vertices.length,i=this.vertices,a=e.vertices,c=this.faces,h=e.faces,u=this.colors,p=e.colors;void 0!==s&&(r=(new t.Matrix3).getNormalMatrix(s));for(let e=0,t=a.length;e<t;e++){const t=a[e].clone();void 0!==s&&t.applyMatrix4(s),i.push(t)}for(let e=0,t=p.length;e<t;e++)u.push(p[e].clone());for(let e=0,t=h.length;e<t;e++){const t=h[e];let s,i;const a=t.vertexNormals,u=t.vertexColors,p=new l(t.a+n,t.b+n,t.c+n);p.normal.copy(t.normal),void 0!==r&&p.normal.applyMatrix3(r).normalize();for(let e=0,t=a.length;e<t;e++)s=a[e].clone(),void 0!==r&&s.applyMatrix3(r).normalize(),p.vertexNormals.push(s);p.color.copy(t.color);for(let e=0,t=u.length;e<t;e++)i=u[e],p.vertexColors.push(i.clone());p.materialIndex=t.materialIndex+o,c.push(p)}for(let t=0,s=e.faceVertexUvs.length;t<s;t++){const s=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,o=s.length;e<o;e++){const o=s[e],r=[];for(let e=0,t=o.length;e<t;e++)r.push(o[e].clone());this.faceVertexUvs[t].push(r)}}}mergeMesh(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)}mergeVertices(e=4){const t={},s=[],o=[],r=Math.pow(10,e);for(let e=0,n=this.vertices.length;e<n;e++){const n=this.vertices[e],i=Math.round(n.x*r)+"_"+Math.round(n.y*r)+"_"+Math.round(n.z*r);void 0===t[i]?(t[i]=e,s.push(this.vertices[e]),o[e]=s.length-1):o[e]=o[t[i]]}const n=[];for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.a=o[t.a],t.b=o[t.b],t.c=o[t.c];const s=[t.a,t.b,t.c];for(let t=0;t<3;t++)if(s[t]===s[(t+1)%3]){n.push(e);break}}for(let e=n.length-1;e>=0;e--){const t=n[e];this.faces.splice(t,1);for(let e=0,s=this.faceVertexUvs.length;e<s;e++)this.faceVertexUvs[e].splice(t,1)}const i=this.vertices.length-s.length;return this.vertices=s,i}setFromPoints(e){this.vertices=[];for(let s=0,o=e.length;s<o;s++){const o=e[s];this.vertices.push(new t.Vector3(o.x,o.y,o.z||0))}return this}sortFacesByMaterialIndex(){const e=this.faces,t=e.length;for(let s=0;s<t;s++)e[s]._id=s;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let r,n;s&&s.length===t&&(r=[]),o&&o.length===t&&(n=[]);for(let i=0;i<t;i++){const t=e[i]._id;r&&r.push(s[t]),n&&n.push(o[t])}r&&(this.faceVertexUvs[0]=r),n&&(this.faceVertexUvs[1]=n)}toJSON(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];t.push(s.x,s.y,s.z)}const s=[],o=[],r={},n=[],i={},l=[],a={};for(let e=0;e<this.faces.length;e++){const t=this.faces[e],o=!0,r=!1,n=void 0!==this.faceVertexUvs[0][e],i=t.normal.length()>0,l=t.vertexNormals.length>0,a=1!==t.color.r||1!==t.color.g||1!==t.color.b,m=t.vertexColors.length>0;let f=0;if(f=c(f,0,0),f=c(f,1,o),f=c(f,2,r),f=c(f,3,n),f=c(f,4,i),f=c(f,5,l),f=c(f,6,a),f=c(f,7,m),s.push(f),s.push(t.a,t.b,t.c),s.push(t.materialIndex),n){const t=this.faceVertexUvs[0][e];s.push(p(t[0]),p(t[1]),p(t[2]))}if(i&&s.push(h(t.normal)),l){const e=t.vertexNormals;s.push(h(e[0]),h(e[1]),h(e[2]))}if(a&&s.push(u(t.color)),m){const e=t.vertexColors;s.push(u(e[0]),u(e[1]),u(e[2]))}}function c(e,t,s){return s?e|1<<t:e&~(1<<t)}function h(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==r[t]||(r[t]=o.length/3,o.push(e.x,e.y,e.z)),r[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=n.length,n.push(e.getHex())),i[t]}function p(e){const t=e.x.toString()+e.y.toString();return void 0!==a[t]||(a[t]=l.length/2,l.push(e.x,e.y)),a[t]}return e.data={},e.data.vertices=t,e.data.normals=o,n.length>0&&(e.data.colors=n),l.length>0&&(e.data.uvs=[l]),e.data.faces=s,e}clone(){return(new n).copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let e=0,s=t.length;e<s;e++)this.vertices.push(t[e].clone());const s=e.colors;for(let e=0,t=s.length;e<t;e++)this.colors.push(s[e].clone());const o=e.faces;for(let e=0,t=o.length;e<t;e++)this.faces.push(o[e].clone());for(let t=0,s=e.faceVertexUvs.length;t<s;t++){const s=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,o=s.length;e<o;e++){const o=s[e],r=[];for(let e=0,t=o.length;e<t;e++){const t=o[e];r.push(t.clone())}this.faceVertexUvs[t].push(r)}}const r=e.morphTargets;for(let e=0,t=r.length;e<t;e++){const t={};if(t.name=r[e].name,void 0!==r[e].vertices){t.vertices=[];for(let s=0,o=r[e].vertices.length;s<o;s++)t.vertices.push(r[e].vertices[s].clone())}if(void 0!==r[e].normals){t.normals=[];for(let s=0,o=r[e].normals.length;s<o;s++)t.normals.push(r[e].normals[s].clone())}this.morphTargets.push(t)}const n=e.morphNormals;for(let e=0,t=n.length;e<t;e++){const t={};if(void 0!==n[e].vertexNormals){t.vertexNormals=[];for(let s=0,o=n[e].vertexNormals.length;s<o;s++){const o=n[e].vertexNormals[s],r={};r.a=o.a.clone(),r.b=o.b.clone(),r.c=o.c.clone(),t.vertexNormals.push(r)}}if(void 0!==n[e].faceNormals){t.faceNormals=[];for(let s=0,o=n[e].faceNormals.length;s<o;s++)t.faceNormals.push(n[e].faceNormals[s].clone())}this.morphNormals.push(t)}const i=e.skinWeights;for(let e=0,t=i.length;e<t;e++)this.skinWeights.push(i[e].clone());const l=e.skinIndices;for(let e=0,t=l.length;e<t;e++)this.skinIndices.push(l[e].clone());const a=e.lineDistances;for(let e=0,t=a.length;e<t;e++)this.lineDistances.push(a[e]);const c=e.boundingBox;null!==c&&(this.boundingBox=c.clone());const h=e.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){const e=(new i).fromGeometry(this),s=new t.BufferGeometry,o=new Float32Array(3*e.vertices.length);if(s.setAttribute("position",new t.BufferAttribute(o,3).copyVector3sArray(e.vertices)),e.normals.length>0){const o=new Float32Array(3*e.normals.length);s.setAttribute("normal",new t.BufferAttribute(o,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const o=new Float32Array(3*e.colors.length);s.setAttribute("color",new t.BufferAttribute(o,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const o=new Float32Array(2*e.uvs.length);s.setAttribute("uv",new t.BufferAttribute(o,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const o=new Float32Array(2*e.uvs2.length);s.setAttribute("uv2",new t.BufferAttribute(o,2).copyVector2sArray(e.uvs2))}s.groups=e.groups;for(const o in e.morphTargets){const r=[],n=e.morphTargets[o];for(let e=0,s=n.length;e<s;e++){const s=n[e],o=new t.Float32BufferAttribute(3*s.data.length,3);o.name=s.name,r.push(o.copyVector3sArray(s.data))}s.morphAttributes[o]=r}if(e.skinIndices.length>0){const o=new t.Float32BufferAttribute(4*e.skinIndices.length,4);s.setAttribute("skinIndex",o.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const o=new t.Float32BufferAttribute(4*e.skinWeights.length,4);s.setAttribute("skinWeight",o.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(s.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(s.boundingBox=e.boundingBox.clone()),s}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(e){let s=new t.BufferGeometry;const o=e.geometry;if(e.isPoints||e.isLine){const e=new t.Float32BufferAttribute(3*o.vertices.length,3),r=new t.Float32BufferAttribute(3*o.colors.length,3);if(s.setAttribute("position",e.copyVector3sArray(o.vertices)),s.setAttribute("color",r.copyColorsArray(o.colors)),o.lineDistances&&o.lineDistances.length===o.vertices.length){const e=new t.Float32BufferAttribute(o.lineDistances.length,1);s.setAttribute("lineDistance",e.copyArray(o.lineDistances))}null!==o.boundingSphere&&(s.boundingSphere=o.boundingSphere.clone()),null!==o.boundingBox&&(s.boundingBox=o.boundingBox.clone())}else e.isMesh&&(s=o.toBufferGeometry());return s}}n.prototype.isGeometry=!0;class i{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,o,r;const n=e.faces;for(o=0;o<n.length;o++){const e=n[o];e.materialIndex!==r&&(r=e.materialIndex,void 0!==s&&(s.count=3*o-s.start,t.push(s)),s={start:3*o,materialIndex:r})}void 0!==s&&(s.count=3*o-s.start,t.push(s)),this.groups=t}fromGeometry(e){const s=e.faces,o=e.vertices,r=e.faceVertexUvs,n=r[0]&&r[0].length>0,i=r[1]&&r[1].length>0,l=e.morphTargets,a=l.length;let c;if(a>0){c=[];for(let e=0;e<a;e++)c[e]={name:l[e].name,data:[]};this.morphTargets.position=c}const h=e.morphNormals,u=h.length;let p;if(u>0){p=[];for(let e=0;e<u;e++)p[e]={name:h[e].name,data:[]};this.morphTargets.normal=p}const m=e.skinIndices,f=e.skinWeights,d=m.length===o.length,g=f.length===o.length;o.length>0&&0===s.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let e=0;e<s.length;e++){const v=s[e];this.vertices.push(o[v.a],o[v.b],o[v.c]);const x=v.vertexNormals;if(3===x.length)this.normals.push(x[0],x[1],x[2]);else{const e=v.normal;this.normals.push(e,e,e)}const y=v.vertexColors;if(3===y.length)this.colors.push(y[0],y[1],y[2]);else{const e=v.color;this.colors.push(e,e,e)}if(!0===n){const s=r[0][e];void 0!==s?this.uvs.push(s[0],s[1],s[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",e),this.uvs.push(new t.Vector2,new t.Vector2,new t.Vector2))}if(!0===i){const s=r[1][e];void 0!==s?this.uvs2.push(s[0],s[1],s[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",e),this.uvs2.push(new t.Vector2,new t.Vector2,new t.Vector2))}for(let e=0;e<a;e++){const t=l[e].vertices;c[e].data.push(t[v.a],t[v.b],t[v.c])}for(let t=0;t<u;t++){const s=h[t].vertexNormals[e];p[t].data.push(s.a,s.b,s.c)}d&&this.skinIndices.push(m[v.a],m[v.b],m[v.c]),g&&this.skinWeights.push(f[v.a],f[v.b],f[v.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class l{constructor(e,s,o,r,n,i=0){this.a=e,this.b=s,this.c=o,this.normal=r&&r.isVector3?r:new t.Vector3,this.vertexNormals=Array.isArray(r)?r:[],this.color=n&&n.isColor?n:new t.Color,this.vertexColors=Array.isArray(n)?n:[],this.materialIndex=i}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}e.Face3=l,e.Geometry=n,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e["THREE-STD"]||{},e.THREE)}();
